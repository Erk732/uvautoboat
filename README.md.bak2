# AutoBoat (uvautoboat)

[![ROS 2 Version](https://img.shields.io/badge/ROS_2-Jazzy-blue)](https://docs.ros.org/en/jazzy/)
[![Gazebo Version](https://img.shields.io/badge/Gazebo-Harmonic-orange)](https://gazebosim.org/)
![ROS 2 CI](https://github.com/osrf/vrx/workflows/ROS%202%20CI/badge.svg)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

> An autonomous navigation system for unmanned surface vehicles (USVs) developed for the Virtual RobotX (VRX) competition.

## Table of Contents

- [Abstract](#abstract)
- [Quick Start](#quick-start)
- [Features](#features)
- [Background Concepts for New Users](#background-concepts-for-new-users)
- [System Architecture](#system-architecture)
- [Installation](#installation)
- [Usage](#usage)
- [Simulation Environment](#simulation-environment)
- [Package Documentation](#package-documentation)
- [Testing](#testing)
- [Troubleshooting](#troubleshooting)
- [Development](#development)
- [References](#references)

---

## Abstract

AutoBoat is an autonomous navigation system for unmanned surface vehicles (USVs) developed for the Virtual RobotX (VRX) competition. The system integrates advanced path planning, real-time obstacle avoidance, and precise trajectory tracking algorithms optimized for the WAM-V maritime platform. Built on ROS 2 Jazzy and Gazebo Harmonic, the framework provides a robust foundation for autonomous maritime navigation in simulated environments.

---

## Quick Start

**Prerequisites**: ROS 2 Jazzy, Gazebo Harmonic, and VRX installed ([Installation Guide](#installation))

```bash
# Terminal 1 - Launch simulation
ros2 launch vrx_gz competition.launch.py world:=sydney_regatta
```

```bash
# Terminal 2 - Run autonomous navigation (choose one)

# Option A: Apollo11 (modular approach)
ros2 run plan apollo11

# Option B: Vostok1 (integrated approach)
ros2 run plan vostok1
```

**Expected Result**: The WAM-V boat autonomously navigates through predefined waypoints while avoiding obstacles.

For detailed testing instructions, see [Testing](#testing).

---

## Features

### Core Capabilities

‚úÖ **Autonomous Navigation** - Fully operational point-to-point navigation system tested on ROS 2 Jazzy + Gazebo Harmonic

‚úÖ **GPS-Based Position Tracking** - Real-time position updates using NavSatFix messages with local coordinate conversion

‚úÖ **LIDAR-Based Obstacle Avoidance** - Real-time 2D/3D point cloud processing for reactive obstacle detection and avoidance

‚úÖ **Waypoint Navigation** - Sequential waypoint following with dynamic path adjustment

‚úÖ **Differential Thrust Control** - Precise trajectory tracking using independent left/right thruster control

‚úÖ **Dual Implementation Approaches** - Both modular (Apollo11) and integrated (Vostok1) autonomous systems

### Technical Highlights

- **Complete Autonomous Systems**: Two fully functional implementations with different architectural approaches
- **Real-Time Perception**: 3D LIDAR-based obstacle detection with configurable safety thresholds
- **Reactive Behaviors**: Stuck detection, recovery maneuvers, and dynamic obstacle response
- **VRX Integration**: Full compatibility with Virtual RobotX simulation environment
- **Simulation Time Support**: Proper synchronization with Gazebo physics simulation
- **Web-Based Monitoring**: Real-time dashboard for mission status visualization (Vostok1)

### Current Status

- ‚úÖ **Phase 1**: Architecture & MVP - **100% Complete**
- ‚úÖ **Phase 2**: Obstacle Avoidance (A*) - **100% Complete**
- ‚è∏Ô∏è **Phase 3**: Coverage & Search - Not Started
- üîÑ **Phase 4**: Integration & Testing - **60% Complete**

See [Board.md](Board.md) for detailed project status and milestones.

---

## Overview

AutoBoat implements a hierarchical autonomous navigation framework designed for maritime surface vehicles operating in complex environments. The system combines perception, planning, and control subsystems to enable intelligent waypoint navigation while dynamically responding to environmental constraints. By processing sensor data streams and mission objectives in real-time, the architecture generates collision-free trajectories that account for static obstacles, operational boundaries, and vehicle dynamics, ensuring safe and efficient autonomous operation.

## Background Concepts for New Users

If you're new to ROS 2 or autonomous navigation, here are some key concepts that will help you understand this system:

### What is ROS 2?

**ROS 2 (Robot Operating System 2)** is a framework for building robot software. Think of it as a communication system that allows different parts of a robot (sensors, planning algorithms, controllers) to talk to each other.

**Key ROS 2 Concepts:**

- **Node**: An independent program that performs a specific task (e.g., path planning, motor control)
- **Topic**: A named channel where nodes send and receive messages (like `/wamv/pose` for boat position)
- **Message**: Data structure sent over topics (e.g., position coordinates, sensor readings)
- **Package**: A collection of related nodes and code organized together

**Example**: In this system, the `apollo11` or `vostok1` node reads GPS data from `/wamv/sensors/gps/gps/fix` and publishes thrust commands to `/wamv/thrusters/left/thrust` and `/wamv/thrusters/right/thrust`.

### What are Coordinate Frames (TF)?

**Coordinate frames** define where things are in 3D space. Different parts of the robot have their own reference frames.

**In this system:**

- `world` or `map`: The global reference frame (like GPS coordinates)
- `wamv/base_link`: The boat's center point
- `wamv/imu_wamv_link`: Where the IMU sensor is located

**Why it matters**: To plan a path, the system needs to know where the boat is relative to the world. The TF (Transform) system automatically converts between these different frames.

### GPS Navigation (Global Positioning System)

**GPS** provides the boat's absolute position on Earth using satellite signals. The WAM-V is equipped with a GPS sensor that publishes data to `/wamv/sensors/gps/gps/fix`.

**How Apollo11 and Vostok1 use GPS:**

1. **Initial Reference Point**: When the mission starts, the first GPS reading becomes the "origin" (0, 0) of the local coordinate system
2. **Position Tracking**: Continuous GPS updates show current position relative to the starting point
3. **Waypoint Navigation**: Target waypoints are defined in local meters from the start position
4. **Distance Calculation**: GPS coordinates are converted to meters using equirectangular projection:
   ```
   x = (lat - start_lat) √ó Earth_radius
   y = (lon - start_lon) √ó Earth_radius √ó cos(start_lat)
   ```

**GPS Data Structure** (`sensor_msgs/NavSatFix`):
- `latitude`: Degrees north/south (-90 to +90)
- `longitude`: Degrees east/west (-180 to +180)
- `altitude`: Height above sea level (meters)

### 3D LIDAR Point Cloud Processing

**LIDAR** (Light Detection and Ranging) uses laser pulses to create a 3D map of the environment. The WAM-V has a 3D LIDAR sensor that publishes point cloud data.

**How Vostok1 uses LIDAR:**

1. **Raw Data**: LIDAR returns thousands of 3D points (x, y, z) representing surfaces it detects
2. **Filtering**: Points are filtered by:
   - **Height**: Only points between water surface (-0.2m) and 3m above are considered obstacles
   - **Distance**: Only points within detection range (e.g., 50m) are processed
3. **Sector Analysis**: Points are divided into sectors:
   - **Front** (-45¬∞ to +45¬∞): For forward obstacle detection
   - **Left** (+45¬∞ to +135¬∞): For left-side clearance
   - **Right** (-135¬∞ to -45¬∞): For right-side clearance
4. **Decision Making**: If minimum distance in front sector < safety threshold ‚Üí trigger avoidance

**Point Cloud Data Structure** (`sensor_msgs/PointCloud2`):
- Each point contains: x, y, z coordinates (in meters from sensor)
- Intensity value (reflection strength)
- Ring/channel information (which laser beam)

**LIDAR vs 2D LaserScan:**
- Apollo11 uses 2D `LaserScan` (single horizontal plane)
- Vostok1 uses 3D `PointCloud2` (full 3D volume) for better obstacle detection

### What is use_sim_time?

When running in simulation (Gazebo), time moves differently than real-world time. The simulation can be paused, slowed down, or sped up.

**The `use_sim_time` parameter** tells ROS 2 nodes to use simulation time instead of your computer's clock. This keeps everything synchronized.

**Always use** `--ros-args -p use_sim_time:=true` when running nodes alongside Gazebo simulation.

### What is Gazebo?

**Gazebo** is a 3D physics simulator that creates realistic virtual environments for testing robots. It simulates:

- Physics (gravity, buoyancy, collisions)
- Sensors (cameras, GPS, IMU)
- Actuators (thrusters, motors)

**Why simulate?** Testing on real boats is expensive and dangerous. Gazebo lets you test your algorithms safely before deploying to hardware.

### How Does Path Planning Work?

Path planning is like using Google Maps for your robot:

1. **Input**: Current position + Goal position
2. **Process**: Algorithm finds obstacle-free path
3. **Output**: Series of waypoints to follow

**A* Algorithm** (used in this system):

- Searches through a grid of possible positions
- Finds the shortest path while avoiding obstacles
- Uses a "heuristic" (educated guess) to search efficiently

### How Does the Control System Work?

The control system is like a driver following GPS directions:

1. **Input**: Desired path from planner
2. **Process**: Calculate steering and throttle commands
3. **Output**: Thruster commands (left/right thrust)

**Differential Thrust Control**:

- Two independent thrusters (left and right)
- To go straight: Both thrusters equal power
- To turn left: Right thruster more power than left
- To turn right: Left thruster more power than right

### Topic Communication Example

**Apollo11/Vostok1 Data Flow:**

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     SENSORS (Gazebo)                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ                    ‚îÇ                    ‚îÇ
           ‚Üì                    ‚Üì                    ‚Üì
    /wamv/sensors/       /wamv/sensors/      /wamv/sensors/
    gps/gps/fix         imu/imu/data        lidars/.../points
           ‚îÇ                    ‚îÇ                    ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚Üì
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   Apollo11 / Vostok1  ‚îÇ
                    ‚îÇ   (Autonomous Node)   ‚îÇ
                    ‚îÇ                       ‚îÇ
                    ‚îÇ ‚Ä¢ GPS ‚Üí Position      ‚îÇ
                    ‚îÇ ‚Ä¢ IMU ‚Üí Heading       ‚îÇ
                    ‚îÇ ‚Ä¢ LIDAR ‚Üí Obstacles   ‚îÇ
                    ‚îÇ ‚Ä¢ PID ‚Üí Control       ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   ‚Üì                         ‚Üì
        /wamv/thrusters/left    /wamv/thrusters/right
                   ‚Üì                         ‚Üì
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ       WAM-V Boat (Gazebo)           ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

This shows how sensor data flows into the autonomous node, which processes it and outputs thruster commands.

---

## System Architecture

The AutoBoat project features two distinct autonomous navigation implementations:

### Apollo11 - Modular Architecture

- **Philosophy**: Clean separation of subsystems
- **Components**: External planner and controller nodes
- **Approach**: Subscribes to planned paths, follows waypoints
- **Best for**: Structured environments with pre-planned routes

### Vostok1 - Integrated Architecture

- **Philosophy**: Self-contained autonomous system
- **Components**: Integrated planning, perception, and control
- **Approach**: Real-time reactive navigation with LIDAR
- **Best for**: Dynamic environments with moving obstacles

Both implementations demonstrate successful autonomous navigation with different trade-offs between modularity and tight integration.

### ROS 2 Communication Interfaces

#### Sensor Topics

| Topic Name | Message Type | Direction | Description |
| :--- | :--- | :--- | :--- |
| `/wamv/sensors/gps/gps/fix` | `sensor_msgs/NavSatFix` | Input | GPS position data |
| `/wamv/sensors/lidars/lidar_wamv_sensor/points` | `sensor_msgs/PointCloud2` | Input | 3D LIDAR point cloud |
| `/wamv/sensors/imu/imu/data` | `sensor_msgs/Imu` | Input | IMU orientation data |

#### Control Topics

| Topic Name | Message Type | Direction | Description |
| :--- | :--- | :--- | :--- |
| `/wamv/thrusters/left/thrust` | `std_msgs/Float64` | Output | Left thruster command (-1000 to 1000 N) |
| `/wamv/thrusters/right/thrust` | `std_msgs/Float64` | Output | Right thruster command (-1000 to 1000 N) |

#### Custom Topics (Vostok1)

| Topic Name | Message Type | Direction | Description |
| :--- | :--- | :--- | :--- |
| `/vostok1/mission_status` | `std_msgs/String` | Output | Mission state and progress (JSON) |
| `/vostok1/obstacle_status` | `std_msgs/String` | Output | Obstacle detection data (JSON) |

---

## Installation

### System Requirements

- **Operating System**: Ubuntu 24.04 LTS
- **Python**: Version 3.10 or higher
- **Memory**: Minimum 8GB RAM (16GB or 32GB recommended)
- **Storage**: At least 40GB available disk space

### Prerequisites

‚ö†Ô∏è **Important**: This package has been tested with ROS 2 Jazzy and Gazebo Harmonic. Using different versions may result in compatibility issues or unexpected behavior.

**Required Software:**

- [ROS 2 Jazzy Jalisco](https://docs.ros.org/en/jazzy/Installation/Ubuntu-Install-Debs.html) - Robot Operating System 2
- [Gazebo Harmonic](https://gazebosim.org/docs/harmonic/install_ubuntu/) - Physics-based simulation environment
- [VRX Simulation](https://github.com/osrf/vrx) - Virtual RobotX competition environment
- Python 3.10+ with pip

**Python Dependencies:**

The following Python packages are automatically installed during the build process:

- `numpy` - Numerical computing
- `matplotlib` - Visualization (optional)
- Other dependencies specified in package configurations

### Installation Instructions

‚ö†Ô∏è **Note**: Please follow these instructions carefully. Skipping steps may result in build failures or runtime errors.

1. **Create and initialize workspace**

   Create a ROS 2 workspace and clone this repository into the `src` directory:

   ```bash
   mkdir -p ~/seal_ws/src
   cd ~/seal_ws/src
   git clone https://github.com/Erk732/uvautoboat.git
   ```

2. **Clone VRX dependencies**

   The VRX simulation environment is required for testing:

   ```bash
   cd ~/seal_ws/src
   git clone https://github.com/osrf/vrx.git
   ```

3. **Source ROS 2 environment**

   Source the ROS 2 installation (default location: `/opt/ros/jazzy/setup.bash`):

   ```bash
   source /opt/ros/jazzy/setup.bash
   ```

4. **Build the workspace**

   Navigate to the workspace root and build all packages:

   ```bash
   cd ~/seal_ws
   colcon build --merge-install
   ```

   For parallel builds (faster compilation):

   ```bash
   colcon build --merge-install --parallel-workers 4
   ```

5. **Source the workspace**

   After successful build, source the workspace overlay:

   ```bash
   source ~/seal_ws/install/setup.bash
   ```

   **Tip**: Add this line to your `~/.bashrc` for automatic sourcing:

   ```bash
   echo "source ~/seal_ws/install/setup.bash" >> ~/.bashrc
   ```

## Usage

### Launch Demo (Alternative Method)

Launch the complete navigation system using the provided demo launch file:

```bash
# Terminal 1 - Launch VRX simulation
ros2 launch vrx_gz competition.launch.py world:=sydney_regatta

# Terminal 2 - Launch navigation demo
ros2 launch plan demo.launch.py
```

**Note**: For step-by-step component launch, see the [Quick Start](#quick-start) section above.

### Running Individual Components

**Primary Method - Autonomous Navigation:**

The recommended way to run autonomous navigation is using either Apollo11 or Vostok1:

```bash
# Apollo11 (Planning team's modular approach)
ros2 run plan apollo11

# Vostok1 (Control team's integrated approach)
ros2 run plan vostok1
```

**Legacy Components** (for development/debugging):

```bash
# Perception and obstacle detection
ros2 run plan simple_perception

# Mission coordination
ros2 run plan mission_trigger

# Simple thruster controller
ros2 run control simple_controller
```

## Simulation Environment

### Default Environment

The system is designed to operate in the standard VRX Sydney Regatta environment:

```bash
ros2 launch vrx_gz competition.launch.py world:=sydney_regatta
```

### Legacy Test Environment (Deprecated)

‚ö†Ô∏è **Deprecation Notice**: The custom test environment is maintained for backward compatibility but is no longer actively developed. Users are advised to utilize the default Sydney Regatta environment for current development and testing.

The `test_environment` directory contains legacy simulation worlds and custom models:

**Custom Worlds:**

- `sydney_regatta_custom.sdf` - Modified environment with additional obstacles and test scenarios

**Custom Models:**

- `cardboardbox/` - Simple obstacle model for collision avoidance testing

**Legacy Environment Launch** (Optional):

1. Configure Gazebo resource path:

   ```bash
   export GZ_SIM_RESOURCE_PATH=$HOME/seal_ws/src/uvautoboat/test_environment:$GZ_SIM_RESOURCE_PATH
   ```

2. Launch custom environment:

   ```bash
   source ~/seal_ws/install/setup.bash
   ros2 launch vrx_gz competition.launch.py world:=sydney_regatta_custom
   ```

### Customizing the Simulation World

‚ö†Ô∏è **Important Note**: The VRX repository (`~/seal_ws/src/vrx`) is itself a Git repository. If you modify VRX world files (e.g., `sydney_regatta.sdf`) or other VRX content and don't want to accidentally push changes to the upstream VRX repository, consider these options:

- **Option 1**: Create custom world files in your own package (e.g., `test_environment/`) and reference them instead
- **Option 2**: Add modified files to `.git/info/exclude` in the VRX directory to ignore them locally without affecting `.gitignore`
- **Option 3**: Use `git update-index --assume-unchanged <file>` to tell Git to ignore changes to specific files
- **Best Practice**: Keep VRX unmodified and create custom worlds in your own workspace directories

#### Adding Models from Gazebo Fuel

To add additional obstacles or objects to your simulation environment, you can download models from the Gazebo Fuel model repository, which is the recommended source.

**Model Repositories:**

- **General Models**: [Gazebo Fuel Collections](https://app.gazebosim.org/OpenRobotics/fuel/collections)
- **VRX-Specific Models**: [VRX Model Collection](https://app.gazebosim.org/OpenRobotics/fuel/collections/VRX)

**Steps to Add Models to Your World:**

1. **Browse and select a model** from Gazebo Fuel (e.g., `cardboard_box`, `construction_barrel`, etc.)

2. **Download the model** (optional - Gazebo can auto-download):

   Models are automatically downloaded when referenced in your SDF file, or you can manually download them to your local model path.

3. **Add the model to your world file**:

   Open your world SDF file (e.g., `sydney_regatta.sdf` or create a custom one) and add the model using the `<include>` tag:

   ```xml
   <world name="sydney_regatta">
     <!-- Existing world content -->
     
     <!-- Add your custom model -->
     <include>
       <uri>https://fuel.gazebosim.org/1.0/OpenRobotics/models/cardboard_box</uri>
       <name>obstacle_box_1</name>
       <pose>10 5 0 0 0 0</pose>  <!-- x y z roll pitch yaw -->
     </include>
     
     <!-- Add multiple instances with different names and positions -->
     <include>
       <uri>https://fuel.gazebosim.org/1.0/OpenRobotics/models/cardboard_box</uri>
       <name>obstacle_box_2</name>
       <pose>15 -3 0 0 0 1.57</pose>
     </include>
   </world>
   ```

4. **Launch with your customized world**:

   ```bash
   ros2 launch vrx_gz competition.launch.py world:=your_custom_world
   ```

**Common Useful Models:**

- `cardboard_box` - Simple box obstacle
- `construction_barrel` - Traffic barrel
- `jersey_barrier` - Concrete barrier
- `brick_wall` - Wall obstacle
- `wooden_peg` - Small marker

**Note**: The `<pose>` tag specifies the model's position (x, y, z) and orientation (roll, pitch, yaw) in meters and radians respectively.

![3D Cartesian Coordinate System](images/3d_coordinate_system.jpg)
*Figure: 3D Cartesian coordinate system showing x, y, z axes. Image: [Primalshell](https://commons.wikimedia.org/wiki/File:3D_Cartesian_Coodinate_Handedness.jpg), [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)*

- **Position** (x, y, z): Coordinates in 3D space measured in **meters**
  - `x`: Forward/backward (Ê≠£Âêë/ÂèçÂêë)
  - `y`: Left/right (Â∑¶/Âè≥)
  - `z`: Up/down (‰∏ä/‰∏ã)
- **Orientation** (roll, pitch, yaw): Rotation angles measured in **radians**
  - `roll`: Rotation around x-axis (ÁªïxËΩ¥ÊóãËΩ¨)
  - `pitch`: Rotation around y-axis (ÁªïyËΩ¥ÊóãËΩ¨)
  - `yaw`: Rotation around z-axis (ÁªïzËΩ¥ÊóãËΩ¨)
  - **Common usage**: `0 0 0` for default upright orientation (no rotation)
  - **Example**: `0 0 1.57` rotates 90¬∞ (œÄ/2 radians) around z-axis

**Note**: The `<pose>` tag specifies the model's position in (x, y, z) and orientation (roll, pitch, yaw)Ôºåin meters and radians respectively.

- **Position** (x, y, z): Coordinates in 3D space in **m**.
  - `x`: Used for going forward (all engines ahead) or backward (all engines sternway)
  - `y`: Left hand turning or righr hand turning
  - `z`: Up or down
- **Orientation** (roll, pitch, yaw): Rotation angle in **rad**.
  - `roll`: Rotation around the x-axis (roll to port side or starboard side)
  - `pitch`: Rotation around the y-axisÔºàpitch up or pitch downÔºâ
  - `yaw`: Rotation around the z-axisÔºàyaw to port direction or starboard direction Ôºâ
  - **Common Values**: `0 0 0` These values are default upright orinetation of the boat
  - **For better understanding**: `0 0 1.57` values will show a 90¬∞ (œÄ/2 in radians) rotation around z-axis(a simple yaw)

### Expected Output

After launching the simulation environment, you should observe the following:

[![VRX Simulation Environment](images/sydney_regatta_gzsim.png)](https://vimeo.com/851696025 "Gazebo Virtual RobotX v. 2.3 - Click to Watch!")

*Figure: Sydney Regatta simulation environment in Gazebo. Source: [VRX Project](https://github.com/osrf/vrx/wiki/running_vrx_tutorial)*

---

## Package Documentation

### Plan Package

The `plan` package implements the planning and perception subsystems for autonomous navigation. This package provides multiple planning algorithms and supporting utilities for environment representation and obstacle detection.

#### Planning Nodes

The plan package focuses on two primary autonomous navigation implementations:

**1. Apollo11** (`apollo11.py`) - Planner-Centric Approach

Developed by the planning team, Apollo11 implements autonomous navigation using 2D LIDAR for obstacle detection and GPS-based waypoint navigation.

**Sensor Usage:**
- **GPS** (`sensor_msgs/NavSatFix`): Position tracking via `/wamv/sensors/gps/gps/fix`
- **IMU** (`sensor_msgs/Imu`): Heading from `/wamv/sensors/imu/imu/data`
- **2D LIDAR** (`sensor_msgs/LaserScan`): Obstacle detection via `/wamv/sensors/lidars/lidar_wamv_sensor/scan`

**Key Features:**
- Lawnmower pattern waypoint generation
- Stuck detection and recovery maneuvers
- Uses Python's `time.time()` for timing

**Run:**

```bash
ros2 run plan apollo11
```

**2. Vostok1** (`vostok1.py`) - Integrated Control Approach

Developed by the control team, Vostok1 implements a self-contained autonomous navigation system with 3D LIDAR-based obstacle avoidance.

**Sensor Usage:**
- **GPS** (`sensor_msgs/NavSatFix`): Position tracking via `/wamv/sensors/gps/gps/fix`
- **IMU** (`sensor_msgs/Imu`): Heading from `/wamv/sensors/imu/imu/data`
- **3D LIDAR** (`sensor_msgs/PointCloud2`): 3D obstacle detection via `/wamv/sensors/lidars/lidar_wamv_sensor/points`

**Key Features:**
- 3D point cloud processing for obstacle detection
- Sector-based obstacle analysis (front/left/right)
- Hysteresis to prevent detection flickering
- PID heading control with configurable gains
- Stuck detection and escape behaviors
- Web-based monitoring dashboard
- Bilingual Russian/English terminal output

**Run:**

```bash
ros2 run plan vostok1
```

### Launch Files

**Demo Launch:**

```bash
ros2 launch plan demo.launch.py
```

### Plan Package Modules

**Primary Autonomous Systems:**
- `apollo11.py` - Planning team's autonomous navigation (2D LIDAR)
- `vostok1.py` - Control team's autonomous navigation (3D LIDAR)

**Supporting Modules:**
- `simple_perception.py` - Obstacle detection utilities
- `mission_trigger.py` - Mission coordination
- `grid_map.py` - Grid-based environment representation

#### Autonomous Navigation Implementations

The plan package includes two complete autonomous navigation implementations developed by different teams:

##### Web Dashboard for Vostok1

Vostok1 includes a real-time web-based monitoring interface with TNO-style Cold War aesthetic for visualizing mission status, GPS trajectory, obstacle detection, and thruster output. Features bilingual Russian/English interface with style switcher (Bureau Mode / Terminal Mode). See `web_dashboard/Readme_webdashboard.md` for setup instructions.

#### Implementation Comparison

| Aspect | Apollo11 | Vostok1 |
|--------|----------|---------|
| **Philosophy** | Modular subsystems | Integrated autonomy |
| **LIDAR Type** | 2D LaserScan | 3D PointCloud2 |
| **Obstacle Detection** | Single horizontal plane | Full 3D volume with height filtering |
| **Timing** | Python `time.time()` | ROS `get_clock()` |
| **Control** | Direct differential thrust | PID-based heading control |
| **Recovery** | Stuck detection + reverse | Escape maneuvers + turning |
| **Monitoring** | Terminal output | Web dashboard + bilingual terminal |

Both implementations successfully navigate waypoints while avoiding obstacles, demonstrating different architectural approaches to autonomous navigation.

---

### Control Package

The `control` package provides utility controllers for thruster testing and validation. Note that Apollo11 and Vostok1 have their own integrated control logic.

#### Control Nodes

**Simple Controller** (`simple_controller`)

Baseline controller for thruster command testing and validation.

```bash
ros2 run control simple_controller
```

### Sensor Interfaces

| Topic Name | Message Type | Description |
| :--- | :--- | :--- |
| `/wamv/sensors/gps/gps/fix` | `sensor_msgs/NavSatFix` | GPS position (lat/lon/alt) |
| `/wamv/sensors/imu/imu/data` | `sensor_msgs/Imu` | IMU orientation and acceleration |
| `/wamv/sensors/lidars/lidar_wamv_sensor/scan` | `sensor_msgs/LaserScan` | 2D LIDAR scan (Apollo11) |
| `/wamv/sensors/lidars/lidar_wamv_sensor/points` | `sensor_msgs/PointCloud2` | 3D LIDAR point cloud (Vostok1) |

### Thruster Interfaces

| Topic Name | Message Type | Description |
| :--- | :--- | :--- |
| `/wamv/thrusters/left/thrust` | `std_msgs/Float64` | Left thruster command (-1000 to +1000) |
| `/wamv/thrusters/right/thrust` | `std_msgs/Float64` | Right thruster command (-1000 to +1000) |

---

## Troubleshooting

### Common Issues and Solutions

#### Issue: Boat Not Moving in Simulation

**Symptoms**: Nodes are running but the WAM-V boat remains stationary.

**Solutions**:

1. **Verify `use_sim_time` parameter**:
   - Ensure all nodes are launched with `--ros-args -p use_sim_time:=true`
   - This synchronizes node time with Gazebo simulation time

2. **Check topic connections**:

   ```bash
   # Verify thrust commands are being published
   ros2 topic echo /wamv/thrusters/left/thrust
   ros2 topic echo /wamv/thrusters/right/thrust

   # Check if path is being generated
   ros2 topic echo /planning/path

   # Verify pose data is available
   ros2 topic echo /wamv/pose
   ```

3. **Check node status**:

   ```bash
   # List active nodes
   ros2 node list

   # Check specific node info
   ros2 node info /apollo11_node
   ros2 node info /vostok1_node
   ```

#### Issue: Boat Not Navigating

**Symptoms**: Boat doesn't move after starting Apollo11 or Vostok1.

**Solutions**:

1. **Check GPS signal**:

   ```bash
   ros2 topic echo /wamv/sensors/gps/gps/fix
   ```

   If no data, ensure Gazebo simulation is running and boat is spawned.

2. **Check node logs**:
   - Look for "Waiting for GPS signal..." message
   - Verify mission starts with "MISSION STARTED" or "–ú–ò–°–°–ò–Ø –ù–ê–ß–ê–¢–ê"

3. **Verify thruster commands**:

   ```bash
   ros2 topic echo /wamv/thrusters/left/thrust
   ```

#### Issue: Build Failures

**Symptoms**: `colcon build` fails with errors.

**Solutions**:

1. **Missing dependencies**:

   ```bash
   # Install ROS 2 dependencies
   cd ~/seal_ws
   rosdep install --from-paths src --ignore-src -r -y
   ```

2. **Clean build**:

   ```bash
   # Remove build artifacts and rebuild
   rm -rf build install log
   colcon build --merge-install
   ```

3. **Python import errors**:
   - Ensure `grid_map.py` exists in `plan/brain/` directory
   - Verify relative imports use correct syntax

#### Issue: Simulation Crashes or Freezes

**Symptoms**: Gazebo becomes unresponsive or crashes.

**Solutions**:

1. **Check system resources**:
   - Verify sufficient RAM (minimum 8GB, recommended 16GB)
   - Monitor CPU usage

2. **Reduce graphics quality**:
   - Lower rendering settings in Gazebo
   - Disable shadows and reflections

3. **Use headless mode** (for testing without GUI):

   ```bash
   ros2 launch vrx_gz competition.launch.py world:=sydney_regatta headless:=true
   ```

### Getting Help

If you encounter issues not covered here:

1. **Check logs**: Review terminal output for error messages and warnings
2. **Verify configuration**: Ensure all parameters match the documentation
3. **Consult VRX documentation**: [VRX Wiki](https://github.com/osrf/vrx/wiki)
4. **Report issues**: Open an issue on the [GitHub repository](https://github.com/Erk732/uvautoboat/issues)

---

## Testing

This section provides comprehensive testing procedures to validate the AutoBoat navigation system.

### Unit Testing

The project includes unit tests for critical components:

```bash
# Run all tests
cd ~/seal_ws
colcon test --packages-select plan control

# View test results
colcon test-result --verbose
```

### Integration Testing

Integration tests validate the complete navigation stack with all components working together.

#### Test 1: Autonomous Navigation ‚úÖ

**Status**: Verified working on ROS 2 Jazzy + Gazebo Harmonic (30/11/2025)

**Objective**: Validate end-to-end autonomous navigation with obstacle avoidance.

**Prerequisites:**

- Ensure all packages are built: `cd ~/seal_ws && colcon build --merge-install`
- Source the workspace: `source ~/seal_ws/install/setup.bash`

**Step-by-Step Testing:**

1. **Terminal 1 - Launch VRX Simulation:**

   ```bash
   ros2 launch vrx_gz competition.launch.py world:=sydney_regatta
   ```

   Wait for Gazebo to fully load and the WAM-V boat to appear in the water.

2. **Terminal 2 - Run Autonomous Navigation (choose one):**

   **Option A - Apollo11:**

   ```bash
   ros2 run plan apollo11
   ```

   You should see:

   ```text
   [INFO] [apollo11_node]: Apollo 11 - Autonomous Navigation System
   [INFO] [apollo11_node]: Waiting for GPS signal...
   [INFO] [apollo11_node]: Mission Started!
   ```

   **Option B - Vostok1:**

   ```bash
   ros2 run plan vostok1
   ```

   You should see bilingual output:

   ```text
   [INFO] [vostok1_node]: –ü–†–û–ï–ö–¢-17 (Proekt-17) - –ê–≤—Ç–æ–Ω–æ–º–Ω–∞—è –ù–∞–≤–∏–≥–∞—Ü–∏—è
   [INFO] [vostok1_node]: Vostok 1 - Autonomous Navigation System
   [INFO] [vostok1_node]: –ú–ò–°–°–ò–Ø –ù–ê–ß–ê–¢–ê! (Mission Started!)
   ```

**Expected Behavior:**

- Boat begins autonomous lawnmower pattern navigation
- Status updates show waypoint progress: `–¢–ú 1/19 | –ü–æ–∑: (x, y) | –¶–µ–ª—å: (tx, ty)`
- Obstacle detection triggers avoidance: `üö® –ü–†–ï–ü–Ø–¢–°–¢–í–ò–ï! | OBSTACLE DETECTED!`
- Path clear resumes navigation: `‚úÖ –ü—É—Ç—å —Å–≤–æ–±–æ–¥–µ–Ω | Path CLEAR`
- Mission completes after all waypoints visited

**Monitoring:**

```bash
# Check thruster commands
ros2 topic echo /wamv/thrusters/left/thrust

# Check GPS data
ros2 topic echo /wamv/sensors/gps/gps/fix

# Check LIDAR data (Vostok1)
ros2 topic echo /wamv/sensors/lidars/lidar_wamv_sensor/points --no-arr
```

#### Test 2: Web Dashboard (Vostok1 only)

**Objective**: Validate real-time web-based monitoring.

**Steps:**

1. Start Vostok1 as described in Test 1

2. **Terminal 3 - Start rosbridge server:**

   ```bash
   ros2 launch rosbridge_server rosbridge_websocket_launch.xml
   ```

3. **Terminal 4 - Start web server:**

   ```bash
   cd ~/seal_ws/src/uvautoboat/web_dashboard
   python3 -m http.server 8000
   ```

4. **Open browser:** Navigate to `http://localhost:8000`

**Expected Behavior:**

- Dashboard shows "–ü–æ–¥–∫–ª—é—á–µ–Ω–æ | Connected" status
- GPS coordinates update in real-time
- Thruster bars show current thrust levels
- Mission status panel shows waypoint progress
- Obstacle status shows detection state with Russian/English text

#### Test 3: Obstacle Avoidance

**Objective**: Validate dynamic obstacle detection and avoidance.

**Steps:**

1. Run either Apollo11 or Vostok1 as in Test 1

2. In Gazebo, manually place obstacles in the boat's path using the GUI

**Expected Behavior:**

- Apollo11: Detects obstacles via 2D LaserScan, triggers avoidance turn
- Vostok1: Detects obstacles via 3D PointCloud2, shows sector analysis
- Both display obstacle warnings in terminal
- Boat maneuvers around obstacles and resumes navigation

### Performance Metrics

Expected system performance benchmarks:

| Metric | Target | Description |
|:-------|:-------|:------------|
| Waypoint Accuracy | < 3m | Distance to waypoint before advancing |
| Control Loop Rate | 20 Hz | Vostok1 update frequency |
| Obstacle Detection | < 50m | LIDAR detection range |
| Collision Avoidance | 100% | Success rate in test scenarios |

---

## Development

### Project Status

For detailed development status, milestones, and task tracking, refer to [Board.md](Board.md).

### Contributing

This project is developed as part of the ROS 2 Autonomous Systems course at IMT Nord Europe. Contributions are welcome from the community.

**Development Guidelines**:

1. **Code Style**: Follow PEP 8 for Python code
2. **Documentation**: Update README and inline comments for significant changes
3. **Testing**: Include unit tests for new functionality
4. **Pull Requests**: Provide clear descriptions of changes and their purpose

## References

- [Virtual RobotX (VRX) Competition](https://github.com/osrf/vrx)
- [ROS 2 Documentation](https://docs.ros.org/en/jazzy/)
- [Gazebo Simulation](https://gazebosim.org/)

## Acknowledgments

This project utilizes the Virtual RobotX (VRX) simulation environment developed by Open Source Robotics Foundation (OSRF). Simulation assets and base environment courtesy of the VRX project.

## License

This project is licensed under the Apache License 2.0 - see individual package files for details.

## Contact

For questions or issues, please open an issue on the [GitHub repository](https://github.com/Erk732/uvautoboat).
