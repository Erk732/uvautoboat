// Performance optimization: Debug mode flag
const DEBUG_MODE = false;  // Set to true to enable console logging

// ROS Connection
let ros;
let connected = false;

// Map variables
let map;
let boatMarker;
let trajectoryLine;
let trajectoryPoints = [];
let waypointMarkers = [];
let waypointPath = null;  // Line connecting waypoints
let currentWaypointMarker = null;  // Highlight current target
let gridLayerGroup = null;  // Grid overlay layer group
let gridEventHandlerRegistered = false;  // Prevent duplicate grid event handlers

// Configuration publisher
let configPublisher = null;
let modularConfigPublisher = null;  // For sputnik planner
let missionCommandPublisher = null;  // Mission command publisher
let modularMissionCommandPublisher = null;  // For sputnik planner

// Track which config inputs have been modified by user (prevents ROS from overwriting)
let dirtyInputs = new Set();
let navModeDirty = false;
let pollutantMarkers = [];

// Performance optimization: Throttle updates
let lastTrajectoryUpdate = 0;
let lastMapPan = 0;
let pendingTrajectoryUpdate = false;

// Camera feed elements
let cameraImageEl = null;
let cameraStatusEl = null;
let cameraTopicInput = null;

// Mission state
let missionState = {
    state: 'IDLE',
    gpsReady: false,
    waypointsGenerated: false,
    missionArmed: false,
    joystickOverride: false,
    waypoints: [],
    currentWaypoint: 0,
    totalWaypoints: 0,
    startLat: null,
    startLon: null
};

const WAYPOINT_STORAGE_KEY = 'vostok1_cached_waypoints';

// Data storage
let currentState = {
    gps: { lat: 0, lon: 0, local_x: 0, local_y: 0 },
    obstacles: { min: Infinity, front: true, left: true, right: true },
    thrusters: { left: 0, right: 0 },
    mission: { state: 'IDLE', waypoint: 0, distance: 0 },
    config: {
        scan_length: 150.0,
        scan_width: 50.0,
        lanes: 8,
        kp: 400.0,
        ki: 20.0,
        kd: 100.0,
        base_speed: 500.0,
        max_speed: 800.0,
        min_safe_distance: 15.0
    },
    world: {
        name: 'unknown',
        hasSmoke: false
    }
};

// Style mode (single mode - normal only)

// Initialize everything when page loads
window.addEventListener('load', () => {
    console.log('Dashboard loading...');
    initMap();
    restorePersistedWaypoints();  // Recover waypoints after hard refresh
    connectToROS();
    initStyleToggle();
    initConfigPanel();
    initMissionControl();  // NEW: Mission control buttons
    initCameraFeed();      // Camera/RViz stream panel
    initTerminal();
    initWorldBanner();
    addLog('Dashboard initialized', 'info');
});

// Style toggle removed - using single normal mode
function initStyleToggle() {
    // Style toggle functionality removed
}

// World banner marquee
function initWorldBanner() {
    const banner = document.getElementById('world-banner-text');
    if (banner) {
        banner.textContent = 'Awaiting world info...';
    }
}

function updateWorldBanner(name, hasSmoke) {
    const banner = document.getElementById('world-banner-text');
    if (!banner) return;
    const smokeText = hasSmoke ? 'with smoke sources detected' : 'no smoke sources detected';
    banner.innerHTML = `Currently loaded world is <b><i>${name || 'unknown'}</i></b> - ${smokeText}`;
}


// Map follow mode
let mapFollowBoat = false;  // Default: don't auto-follow

// Update follow button visual state
function updateFollowButtonState() {
    const btn = document.getElementById('follow-boat-toggle');
    if (btn) {
        if (mapFollowBoat) {
            btn.innerHTML = 'ðŸ”’';
            btn.classList.add('active');
            btn.title = 'Following active (click to disable) | Suivi actif';
        } else {
            btn.innerHTML = 'ðŸŽ¯';
            btn.classList.remove('active');
            btn.title = 'Click to follow boat | Suivre le navire';
        }
    }
}

// Initialize Leaflet map
function initMap() {
    // Initialize map at Sydney Regatta Centre approximate location
    map = L.map('map').setView([-33.8361, 151.0697], 16);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);
    
    // Custom boat icon
    const boatIcon = L.divIcon({
        className: 'boat-marker',
        html: 'ðŸš¤',
        iconSize: [30, 30],
        iconAnchor: [15, 15]
    });
    
    boatMarker = L.marker([-33.8361, 151.0697], { icon: boatIcon }).addTo(map);
    trajectoryLine = L.polyline([], { color: '#667eea', weight: 3 }).addTo(map);
    
    // Add follow boat toggle button
    const FollowBoatControl = L.Control.extend({
        options: { position: 'topright' },
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control follow-boat-control');
            const button = L.DomUtil.create('a', 'follow-boat-btn', container);
            button.href = '#';
            button.title = 'Follow boat | Suivre le navire';
            button.innerHTML = 'ðŸŽ¯';
            button.id = 'follow-boat-toggle';
            
            L.DomEvent.on(button, 'click', function(e) {
                L.DomEvent.preventDefault(e);
                L.DomEvent.stopPropagation(e);
                mapFollowBoat = !mapFollowBoat;
                updateFollowButtonState();
                if (mapFollowBoat && currentState.gps.lat !== 0) {
                    map.panTo([currentState.gps.lat, currentState.gps.lon]);
                }
            });
            
            return container;
        }
    });
    
    map.addControl(new FollowBoatControl());
    updateFollowButtonState();

    // Add grid overlay to map
    addGridOverlay();

    addLog('Map initialized', 'info');
}

// Add grid overlay to map (OPTIMIZED - fixes infinite loop)
function addGridOverlay() {
    if (!map) return;

    // Initialize grid layer group once
    if (!gridLayerGroup) {
        gridLayerGroup = L.layerGroup().addTo(map);
    }

    // Clear existing grid lines efficiently
    gridLayerGroup.clearLayers();

    // Get map bounds
    const bounds = map.getBounds();
    const center = map.getCenter();

    // Grid spacing in meters (approximate - will vary with zoom)
    const gridSpacingMeters = 50; // 50 meter grid
    const metersPerDegreeLat = 111000; // Approximate
    const metersPerDegreeLon = 111000 * Math.cos(center.lat * Math.PI / 180);

    const gridSpacingLat = gridSpacingMeters / metersPerDegreeLat;
    const gridSpacingLon = gridSpacingMeters / metersPerDegreeLon;

    // Calculate grid lines
    const minLat = Math.floor(bounds.getSouth() / gridSpacingLat) * gridSpacingLat;
    const maxLat = Math.ceil(bounds.getNorth() / gridSpacingLat) * gridSpacingLat;
    const minLon = Math.floor(bounds.getWest() / gridSpacingLon) * gridSpacingLon;
    const maxLon = Math.ceil(bounds.getEast() / gridSpacingLon) * gridSpacingLon;

    // Draw latitude lines (horizontal)
    for (let lat = minLat; lat <= maxLat; lat += gridSpacingLat) {
        L.polyline(
            [[lat, bounds.getWest()], [lat, bounds.getEast()]],
            {
                color: '#3498db',
                weight: 1,
                opacity: 0.3,
                dashArray: '5, 5',
                interactive: false
            }
        ).addTo(gridLayerGroup);
    }

    // Draw longitude lines (vertical)
    for (let lon = minLon; lon <= maxLon; lon += gridSpacingLon) {
        L.polyline(
            [[bounds.getSouth(), lon], [bounds.getNorth(), lon]],
            {
                color: '#3498db',
                weight: 1,
                opacity: 0.3,
                dashArray: '5, 5',
                interactive: false
            }
        ).addTo(gridLayerGroup);
    }

    // Register event handler ONLY ONCE (prevents infinite loop)
    if (!gridEventHandlerRegistered) {
        gridEventHandlerRegistered = true;
        map.on('moveend zoomend', function() {
            // Redraw grid without re-registering handler
            addGridOverlay();
        });
    }
}

// Connect to ROS via rosbridge
function connectToROS() {
    console.log('Attempting to connect to ws://localhost:9090...');
    ros = new ROSLIB.Ros({
        url: 'ws://localhost:9090'
    });

    ros.on('connection', () => {
        console.log('Connected to rosbridge!');
        connected = true;
        updateConnectionStatus(true);
        addLog('Connected to rosbridge', 'info');
        subscribeToTopics();
    });

    ros.on('error', (error) => {
        console.error('ROS connection error:', error);
        connected = false;
        updateConnectionStatus(false);
        addLog(`Connection error: ${error}`, 'error');
    });

    ros.on('close', () => {
        console.log('Connection closed');
        connected = false;
        updateConnectionStatus(false);
        addLog('Connection closed. Retrying in 5s...', 'warning');
        setTimeout(connectToROS, 5000);
    });
}

// Initialize camera/RViz stream panel using web_video_server
function initCameraFeed() {
    cameraImageEl = document.getElementById('camera-image');
    cameraStatusEl = document.getElementById('camera-status');
    cameraTopicInput = document.getElementById('camera-topic');
    const refreshBtn = document.getElementById('btn-refresh-camera');

    if (refreshBtn) {
        refreshBtn.addEventListener('click', updateCameraStream);
    }

    if (!cameraImageEl || !cameraStatusEl || !cameraTopicInput) {
        return;
    }

    cameraImageEl.addEventListener('load', () => {
        cameraStatusEl.textContent = 'Streaming | Flux en cours';
        cameraStatusEl.classList.remove('error');
    });

    cameraImageEl.addEventListener('error', () => {
        cameraStatusEl.textContent = 'Camera feed unavailable. Start web_video_server? | Flux indisponible';
        cameraStatusEl.classList.add('error');
    });

    updateCameraStream();
}

function updateCameraStream() {
    if (!cameraImageEl || !cameraTopicInput || !cameraStatusEl) {
        return;
    }
    const topic = cameraTopicInput.value.trim() || '/wamv/sensors/cameras/front_left_camera_sensor/image_raw';
    cameraStatusEl.textContent = `Connecting to ${topic}...`;
    const streamUrl = buildCameraUrl(topic);
    // Cache-bust each refresh to force a reconnect
    cameraImageEl.src = `${streamUrl}&t=${Date.now()}`;
}

function buildCameraUrl(topic) {
    // Use the current host so you don't need a separate tab on another localhost/host.
    const baseHost = window.location.hostname || 'localhost';
    const base = `${window.location.protocol}//${baseHost}:8080/stream`;
    // web_video_server expects the topic path unencoded (slashes are valid), so build manually.
    return `${base}?topic=${topic}&type=mjpeg&quality=80`;
}

// Update connection status indicator
function updateConnectionStatus(isConnected) {
    const statusElement = document.getElementById('connection-status');
    if (isConnected) {
        statusElement.textContent = 'Connected | ConnectÃ©';
        statusElement.className = 'status connected';
    } else {
        statusElement.textContent = 'Disconnected | DÃ©connectÃ©';
        statusElement.className = 'status disconnected';
    }
}

// Subscribe to ROS topics
function subscribeToTopics() {
    console.log('Subscribing to topics...');
    
    // GPS Fix
    const gpsTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/wamv/sensors/gps/gps/fix',
        messageType: 'sensor_msgs/NavSatFix'
    });

    gpsTopic.subscribe((message) => {
        console.log('GPS data received:', message.latitude, message.longitude);
        updateGPS(message);
    });

    // Left thruster
    const leftThrustTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/wamv/thrusters/left/thrust',
        messageType: 'std_msgs/Float64'
    });

    leftThrustTopic.subscribe((message) => {
        console.log('Left thrust:', message.data);
        updateThruster('left', message.data);
    });

    // Right thruster
    const rightThrustTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/wamv/thrusters/right/thrust',
        messageType: 'std_msgs/Float64'
    });

    rightThrustTopic.subscribe((message) => {
        console.log('Right thrust:', message.data);
        updateThruster('right', message.data);
    });
    
    // Mission status (integrated and modular)
    const missionStatusTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/planning/mission_status',
        messageType: 'std_msgs/String'
    });
    
    missionStatusTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Mission status:', data);
        updateMissionStatus(data);
        updateDetourBadge(data.detour_active || false);
    });
    
    // Obstacle status
    const obstacleStatusTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/vostok1/obstacle_status',
        messageType: 'std_msgs/String'
    });
    
    obstacleStatusTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Obstacle status:', data);
        updateObstacleStatus(data);
    });
    
    // Simple Anti-Stuck Status
    const antiStuckTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/vostok1/anti_stuck_status',
        messageType: 'std_msgs/String'
    });
    
    antiStuckTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Anti-stuck status:', data);
        updateAntiStuckStatus(data);
    });
    
    // Also subscribe to modular controller anti-stuck (for modular mode)
    const buranAntiStuckTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/control/anti_stuck_status',
        messageType: 'std_msgs/String'
    });
    
    buranAntiStuckTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Buran anti-stuck status:', data);
        updateAntiStuckStatus(data);
    });

    // ==================== MODULAR NAVIGATION SUPPORT ====================
// Subscribe to modular navigation topics (sputnik_planner, oko_perception, buran_controller)
    
    // Modular mission status from sputnik_planner
    const modularMissionTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/planning/mission_status',
        messageType: 'std_msgs/String'
    });
    
    modularMissionTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Modular mission status:', data);
        // Convert modular format to vostok1 format
        // Sputnik uses: current_waypoint, total_waypoints, progress_percent, elapsed_time, position
        updateMissionStatus({
            state: data.state,
            waypoint: data.current_waypoint,
            total_waypoints: data.total_waypoints,
            distance_to_waypoint: data.distance_to_target || 0,
            // Add local position from sputnik's position array
            local_x: data.position ? data.position[0] : 0,
            local_y: data.position ? data.position[1] : 0
        });
    });
    
    // Modular current target from sputnik_planner (for distance info)
    const modularTargetTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/planning/current_target',
        messageType: 'std_msgs/String'
    });
    
    modularTargetTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Modular current target:', data);
        // Update distance to waypoint display
        if (data.distance_to_target !== undefined) {
            document.getElementById('distance').textContent = data.distance_to_target.toFixed(1) + 'm';
        }
    });
    
    // Modular waypoints from sputnik_planner
    const modularWaypointsTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/planning/waypoints',
        messageType: 'std_msgs/String'
    });
    
    modularWaypointsTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Modular waypoints received:', data);
        if (data.waypoints && data.waypoints.length > 0) {
            // Check if waypoints actually changed
            const newWpString = JSON.stringify(data.waypoints);
            const oldWpString = JSON.stringify(missionState.waypoints);
            const waypointsChanged = newWpString !== oldWpString;
            
            missionState.waypoints = data.waypoints;
            missionState.totalWaypoints = data.total || data.waypoints.length;
            persistWaypoints();
            displayWaypointsOnMap(data.waypoints, waypointsChanged);
        } else {
            clearWaypoints('Planner cleared waypoints');
        }
    });
    
    // Modular obstacle status from oko_perception
    const modularObstacleTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/perception/obstacle_info',
        messageType: 'std_msgs/String'
    });
    
    modularObstacleTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Modular obstacle status:', data);
        // Convert modular format to vostok1 format with OKO v2.0/v2.1 enhancements
        // OKO v2.0: front_clear, left_clear, right_clear ARE the distances in meters
        const CLEAR_THRESHOLD = 10.0;  // Distance threshold for "clear" status
        updateObstacleStatus({
            min_distance: data.min_distance,
            // OKO v2.0: Use distance values for both boolean and numeric display
            front_clear: data.front_clear > CLEAR_THRESHOLD,
            left_clear: data.left_clear > CLEAR_THRESHOLD,
            right_clear: data.right_clear > CLEAR_THRESHOLD,
            front_distance: data.front_clear,  // OKO v2.0: front_clear IS the distance
            left_distance: data.left_clear,    // OKO v2.0: left_clear IS the distance
            right_distance: data.right_clear,  // OKO v2.0: right_clear IS the distance
            status: data.force_avoid_active ? 'ðŸ”´ FORCE AVOID | Ã‰vitement forcÃ©' :
                    data.is_critical ? 'ðŸš¨ CRITICAL | Critique' :
                    data.obstacle_detected ? 'âš ï¸ OBSTACLE | DÃ©tectÃ©' :
                    'âœ… CLEAR | DÃ©gagÃ©',
            // OKO v2.0 enhanced fields
            urgency: data.urgency || 0.0,
            obstacle_count: data.obstacle_count || 0,
            best_gap: data.best_gap || null,
            clusters: data.clusters || [],
            moving_obstacles: data.moving_obstacles || [],  // OKO v2.0: array of {id, vx, vy, speed}
            // OKO v2.1 enhanced fields
            vfh_gap: data.vfh_gap || null,           // VFH best direction
            polar_bias: data.polar_bias || 0.0,      // Steering bias [-1, 1]
            force_avoid_active: data.force_avoid_active || false,
            laserscan_fused: data.laserscan_fused || false
        });
    });
    
    // Modular controller status from buran_controller
    const modularControlTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/control/status',
        messageType: 'std_msgs/String'
    });
    
    modularControlTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Modular control status:', data);
        if (data.stop_override !== undefined) {
            missionState.stopOverride = !!data.stop_override;
            const el = document.getElementById('stop-override');
            if (el) {
                el.textContent = missionState.stopOverride ? 'STOP LATCHED' : 'Inactive';
                el.className = 'value ' + (missionState.stopOverride ? 'warning' : '');
            }
        }
    });

    // DEPRECATED: Pollutant sources (smoke generators) from SDF files
    // Replaced by LiDAR-based smoke detection (/perception/smoke_detected)
    // Kept for backward compatibility if pollutant_scan_enabled is re-enabled
    const pollutantTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/perception/pollutant_sources',
        messageType: 'std_msgs/String'
    });

    pollutantTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Pollutant sources update (deprecated):', data);
        if (data.sources) {
            updatePollutantSources(data.sources);  // Still updates minimap markers if enabled
        }
        // Note: UI panel removed - using LiDAR smoke detection panel instead
    });

    // LiDAR Smoke Detection (v2.2) - Active smoke detection
    const smokeDetectionTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/perception/smoke_detected',
        messageType: 'std_msgs/String'
    });

    smokeDetectionTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Smoke detection update:', data);
        updateSmokeDetection(data);
    });

    console.log('Subscribed to all topics (integrated + modular)');
    addLog('Subscribed to topics (Vostok1 + Modular)', 'info');
    
    // Enable mission control UI when connected (before config received)
    updateMissionControlUI({ state: 'IDLE', gps_ready: true });
    
    // Create publisher for configuration updates (Sputnik modular mode only)
    configPublisher = new ROSLIB.Topic({
        ros: ros,
        name: '/sputnik/set_config',
        messageType: 'std_msgs/String'
    });

    // Backward compatibility alias
    modularConfigPublisher = configPublisher;
    
    // Subscribe to current config (Sputnik modular mode only)
    const modularConfigTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/sputnik/config',
        messageType: 'std_msgs/String'
    });
    
    modularConfigTopic.subscribe((message) => {
        const data = JSON.parse(message.data);
        console.log('Config received (sputnik):', data);
        updateConfigFromROS(data);
        updateWorldFromConfig(data);
    });
    
    // Create mission command publisher (Sputnik modular mode only)
    missionCommandPublisher = new ROSLIB.Topic({
        ros: ros,
        name: '/sputnik/mission_command',
        messageType: 'std_msgs/String'
    });

    // Backward compatibility alias
    modularMissionCommandPublisher = missionCommandPublisher;
    
    // Subscribe to ROS logs (rosout)
    const rosoutTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/rosout',
        messageType: 'rcl_interfaces/Log'
    });
    
    rosoutTopic.subscribe((message) => {
        // Filter for vostok1 and modular node messages
        if (message.name && (
            message.name.includes('vostok1') ||
            message.name.includes('sputnik') ||
            message.name.includes('oko') ||
            message.name.includes('buran')
        )) {
            addTerminalLine(message);
        }
    });
    
    addTerminalLine({ level: 20, msg: 'Connected to ROS | ConnectÃ© Ã  ROS', name: 'system' });
}

// ========== CAMERA STREAMING ==========
let cameraTopic = null;
let cameraImage = document.getElementById('camera-image');
let cameraStatus = document.getElementById('camera-status');

function initializeCamera() {
    if (!connected) {
        console.log('ROS not connected, skipping camera initialization');
        return;
    }
    
    const defaultTopic = '/wamv/sensors/camera/image_raw';
    subscribeToCamera(defaultTopic);
    
    // Set up refresh button
    document.getElementById('btn-refresh-camera').addEventListener('click', () => {
        const topic = document.getElementById('camera-topic').value;
        if (cameraTopic) {
            cameraTopic.unsubscribe();
        }
        subscribeToCamera(topic);
    });
}

function subscribeToCamera(topicName) {
    try {
        // Create video stream using ros bridge
        cameraTopic = new ROSLIB.Topic({
            ros: ros,
            name: topicName,
            messageType: 'sensor_msgs/Image'
        });
        
        // Subscribe and display images
        cameraTopic.subscribe((message) => {
            try {
                // Convert ROS image message to base64 and display
                const imageData = message.data;
                if (imageData && imageData.length > 0) {
                    // Decode base64 image
                    const binaryString = atob(imageData);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const blob = new Blob([bytes], { type: 'image/jpeg' });
                    const url = URL.createObjectURL(blob);
                    
                    cameraImage.src = url;
                    cameraStatus.style.display = 'none';
                    cameraImage.style.display = 'block';
                }
            } catch (e) {
                console.error('Error processing camera image:', e);
                cameraStatus.textContent = `Error: ${e.message}`;
                cameraStatus.style.display = 'block';
            }
        });
        
        console.log(`âœ“ Camera subscribed to: ${topicName}`);
        cameraStatus.textContent = `Camera: ${topicName}`;
        cameraStatus.style.display = 'block';
        addLog(`âœ“ Camera feed initialized | Flux camÃ©ra initialisÃ©: ${topicName}`, 'info');
        
    } catch (error) {
        console.error('Error subscribing to camera topic:', error);
        cameraStatus.textContent = `Error: Cannot connect to ${topicName}`;
        cameraStatus.style.display = 'block';
        addLog(`âœ— Camera initialization failed | Ã‰chec: ${error.message}`, 'error');
    }
}

// Update GPS data
function updateGPS(message) {
    currentState.gps.lat = message.latitude;
    currentState.gps.lon = message.longitude;
    
    // Update display
    document.getElementById('latitude').textContent = message.latitude.toFixed(6) + 'Â°';
    document.getElementById('longitude').textContent = message.longitude.toFixed(6) + 'Â°';
    
    // Update map
    const latLng = [message.latitude, message.longitude];
    boatMarker.setLatLng(latLng);
    
    // Add to trajectory
    trajectoryPoints.push(latLng);
    if (trajectoryPoints.length > 300) {
        trajectoryPoints.shift(); // Keep last 300 points (extended trail)
    }
    trajectoryLine.setLatLngs(trajectoryPoints);
    
    // Center map on boat only if follow mode is enabled
    if (mapFollowBoat) {
        const center = map.getCenter();
        const distance = map.distance(center, latLng);
        if (distance > 50) { // More than 50m from center
            map.panTo(latLng);
        }
    }
}

// Update thruster data
function updateThruster(side, value) {
    currentState.thrusters[side] = value;
    
    // Update display (in Newtons)
    document.getElementById(`${side}-thrust`).textContent = value.toFixed(1) + ' N';
    
    // Update thrust bar
    const bar = document.getElementById(`${side}-thrust-bar`);
    const percentage = Math.min(Math.abs(value) / 1000 * 100, 100);
    bar.style.width = percentage + '%';
    
    // Color based on direction
    if (value < 0) {
        bar.classList.add('reverse');
    } else {
        bar.classList.remove('reverse');
    }
}

// Simulate mission data (would come from custom topics in real implementation)
function updateMissionStatus(data) {
    currentState.mission.state = data.state || 'UNKNOWN';
    currentState.mission.waypoint = data.waypoint || 0;
    missionState.blockedReason = data.blocked_reason || '';
    // Detour badge
    updateDetourBadge(!!data.detour_active);
    // Guard against missing distance fields to avoid crashes on refresh
    const distance = (data.distance_to_waypoint !== undefined && data.distance_to_waypoint !== null)
        ? data.distance_to_waypoint
        : 0;
    currentState.mission.distance = distance;
    
    // CRITICAL: Update missionState.currentWaypoint so waypoints on map reflect current progress
    // This is needed for displayWaypointsOnMap() to show correct waypoint coloring (passed/current/pending)
    const previousWaypoint = missionState.currentWaypoint;
    missionState.currentWaypoint = data.waypoint || 0;
    // Sync totals if provided
    if (data.total_waypoints !== undefined) {
        missionState.totalWaypoints = data.total_waypoints || 0;
        // If planner reports zero waypoints, clear map so stale routes disappear
        if (missionState.totalWaypoints === 0 && missionState.waypoints.length > 0) {
            clearWaypoints('Planner reported 0 waypoints');
        } else {
            persistWaypoints();
        }
    }
    
    // If waypoint changed, redraw waypoints on map to update colors (green for passed, orange for current)
    if (previousWaypoint !== missionState.currentWaypoint && missionState.waypoints.length > 0) {
        console.log(`Waypoint updated: ${previousWaypoint} â†’ ${missionState.currentWaypoint}, redrawing map`);
        displayWaypointsOnMap(missionState.waypoints, false);  // Don't fit to bounds, just update colors
    }
    
    document.getElementById('state').textContent = (data.state || 'UNKNOWN').replace(/_/g, ' ');
    document.getElementById('waypoint').textContent = `${data.waypoint || 0}/${data.total_waypoints || missionState.totalWaypoints || 0}`;
    document.getElementById('distance').textContent = distance.toFixed(1) + 'm';
    const blockedEl = document.getElementById('blocked-reason');
    if (blockedEl) {
        const reason = missionState.blockedReason || 'None';
        blockedEl.textContent = reason;
    }
}

// Show/hide detour badge
function updateDetourBadge(isActive) {
    const badge = document.getElementById('detour-badge');
    if (!badge) return;
    badge.style.display = isActive ? 'inline-block' : 'none';
}

// Simulate obstacle data (would parse from PointCloud2 or custom topic)
function updateObstacleStatus(data) {
    currentState.obstacles.min = data.min_distance;
    currentState.obstacles.front = data.front_clear;
    currentState.obstacles.left = data.left_clear;
    currentState.obstacles.right = data.right_clear;
    
    const minDist = data.min_distance;
    document.getElementById('min-obstacle').textContent = 
        minDist >= 999 ? 'âˆž' : minDist.toFixed(1) + 'm';
    
    document.getElementById('front-clear').textContent = 
        data.front_clear ? `âœ“ ${data.front_distance.toFixed(1)}m` : `âœ— ${data.front_distance.toFixed(1)}m`;
    document.getElementById('left-clear').textContent = 
        data.left_clear ? `âœ“ ${data.left_distance.toFixed(1)}m` : `âœ— ${data.left_distance.toFixed(1)}m`;
    document.getElementById('right-clear').textContent = 
        data.right_clear ? `âœ“ ${data.right_distance.toFixed(1)}m` : `âœ— ${data.right_distance.toFixed(1)}m`;
    
    // OKO v2.0: Update urgency display if element exists
    const urgencyEl = document.getElementById('urgency');
    if (urgencyEl && data.urgency !== undefined) {
        const urgencyPct = (data.urgency * 100).toFixed(0);
        urgencyEl.textContent = `${urgencyPct}%`;
        urgencyEl.className = data.urgency > 0.7 ? 'value critical' : 
                              data.urgency > 0.3 ? 'value warning' : 'value';
    }
    
    // OKO v2.0: Update obstacle count if element exists
    const countEl = document.getElementById('obstacle-count');
    if (countEl && data.obstacle_count !== undefined) {
        countEl.textContent = data.obstacle_count;
    }
    
    // OKO v2.0: Update best gap if element exists
    const gapEl = document.getElementById('best-gap');
    if (gapEl && data.best_gap) {
        const gap = data.best_gap;
        gapEl.textContent = `${gap.direction.toFixed(0)}Â° (${gap.width.toFixed(0)}Â°)`;
    }
    
    // Update status badge with bilingual message from vostok1
    const statusBadge = document.getElementById('obstacle-status');
    if (data.status) {
        // Use the bilingual status text from vostok1.py
        statusBadge.textContent = data.status;
        
        // Set class based on emoji indicator
        if (data.status.includes('âœ…')) {
            statusBadge.className = 'value badge clear';
        } else if (data.status.includes('ðŸš¨')) {
            statusBadge.className = 'value badge critical';
        } else {
            statusBadge.className = 'value badge warning';
        }
    } else {
        // Fallback to old behavior if status not provided
        if (minDist > 15 || minDist >= 999) {
            statusBadge.textContent = 'Clear | DÃ©gagÃ©';
            statusBadge.className = 'value badge clear';
        } else if (minDist > 5) {
            statusBadge.textContent = 'Warning | Attention';
            statusBadge.className = 'value badge warning';
        } else {
            statusBadge.textContent = 'Critical | Critique';
            statusBadge.className = 'value badge critical';
        }
    }
}

// Update Simple Anti-Stuck Status
function updateAntiStuckStatus(data) {
    // Update anti-stuck panel elements if they exist
    const stuckStatus = document.getElementById('stuck-status');
    const escapePhase = document.getElementById('escape-phase');
    const noGoZones = document.getElementById('no-go-zones');
    const driftVector = document.getElementById('drift-vector');
    const escapeHistory = document.getElementById('escape-history');
    const probeResults = document.getElementById('probe-results');
    
    if (stuckStatus) {
        if (data.is_stuck && data.escape_mode) {
            stuckStatus.textContent = `STUCK | BLOQUÃ‰ (Attempt ${data.consecutive_attempts})`;
            stuckStatus.className = 'value badge critical';
        } else {
            stuckStatus.textContent = 'Normal';
            stuckStatus.className = 'value badge clear';
        }
    }

    if (escapePhase) {
        escapePhase.textContent = data.escape_mode ? 'TURNING LEFT | Virage Gauche' : 'IDLE | Attente';
        escapePhase.className = data.escape_mode ? 'value active' : 'value';
    }

    if (noGoZones) {
        noGoZones.textContent = 'N/A (Simple mode)';
    }

    if (driftVector) {
        const dx = data.drift_vector[0];
        const dy = data.drift_vector[1];
        const magnitude = Math.hypot(dx, dy);
        if (magnitude > 0.1) {
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            driftVector.textContent = `${magnitude.toFixed(2)} m/s @ ${angle.toFixed(0)}Â°`;
        } else {
            driftVector.textContent = 'Minimal';
        }
    }
    
    // Display Kalman filter uncertainty
    const driftUncertainty = document.getElementById('drift-uncertainty');
    if (driftUncertainty && data.drift_uncertainty) {
        const ux = data.drift_uncertainty[0];
        const uy = data.drift_uncertainty[1];
        const avgUncertainty = Math.hypot(ux, uy);
        if (avgUncertainty < 0.1) {
            driftUncertainty.textContent = 'High conf. | Haute conf.';
            driftUncertainty.style.color = '#4CAF50';
        } else if (avgUncertainty < 0.5) {
            driftUncertainty.textContent = `Ïƒ=${avgUncertainty.toFixed(2)}`;
            driftUncertainty.style.color = '#FFC107';
        } else {
            driftUncertainty.textContent = `Ïƒ=${avgUncertainty.toFixed(2)} (converging | convergence)`;
            driftUncertainty.style.color = '#FF9800';
        }
    }

    if (escapeHistory) {
        escapeHistory.textContent = 'N/A (Simple mode)';
    }

    if (probeResults) {
        probeResults.textContent = `Front: ${data.front_clear ? data.front_clear.toFixed(1) : 'N/A'}m`;
    }

    // Update best direction indicator if exists
    const bestDirection = document.getElementById('best-direction');
    if (bestDirection) {
        bestDirection.textContent = 'â† LEFT | Gauche (fixed)';
    }

    // Add terminal log for stuck events
    if (data.is_stuck && data.escape_mode) {
        addTerminalLine({
            level: 30,  // WARN
            msg: `Simple escape: Turning left until clear (front: ${data.front_clear}m)`,
            name: 'anti_stuck'
        });
    }
}

// Add log entry
function addLog(message, type = 'info') {
    const logsContainer = document.getElementById('logs');
    const logEntry = document.createElement('div');
    logEntry.className = `log-entry ${type}`;
    
    const timestamp = new Date().toLocaleTimeString();
    logEntry.innerHTML = `
        <span class="timestamp">[${timestamp}]</span>
        <span class="message">${message}</span>
    `;
    
    logsContainer.insertBefore(logEntry, logsContainer.firstChild);
    
    // Keep only last 50 logs
    while (logsContainer.children.length > 50) {
        logsContainer.removeChild(logsContainer.lastChild);
    }
}

// Convert GPS to local coordinates (simplified)
function gpsToLocal(lat, lon) {
    // This is a simplified conversion - vostok1 uses proper UTM conversion
    // For display purposes only
    const originLat = -33.8361;
    const originLon = 151.0697;
    
    const latDiff = (lat - originLat) * 111320; // meters per degree latitude
    const lonDiff = (lon - originLon) * 111320 * Math.cos(originLat * Math.PI / 180);
    
    return { x: lonDiff, y: latDiff };
}

// Update local coordinates display
setInterval(() => {
    const local = gpsToLocal(currentState.gps.lat, currentState.gps.lon);
    document.getElementById('local-x').textContent = local.x.toFixed(1) + 'm';
    document.getElementById('local-y').textContent = local.y.toFixed(1) + 'm';
}, 1000);

// Initialize configuration panel
function initConfigPanel() {
    console.log('Initializing config panel...');

    // All config input IDs
    const allConfigInputs = [
        'cfg-lanes', 'cfg-scan-length', 'cfg-scan-width',
        'cfg-kp', 'cfg-ki', 'cfg-kd',
        'cfg-base-speed', 'cfg-max-speed', 'cfg-safe-dist',
        'cfg-astar-resolution', 'cfg-astar-safety', 'cfg-astar-max',
        'wp-lanes', 'wp-length', 'wp-width'
    ];

    // Mark input as dirty when user types
    allConfigInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('input', () => {
                dirtyInputs.add(id);
                el.classList.add('input-dirty');
            });
            // Also mark dirty on focus (user intends to edit)
            el.addEventListener('focus', () => {
                dirtyInputs.add(id);
                el.classList.add('input-dirty');
            });
        }
    });

    // Navigation mode radio buttons - show/hide advanced A* params
    const navModeRadios = document.querySelectorAll('input[name="nav-mode"]');
    const advancedParams = document.getElementById('astar-advanced-params');

    navModeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            navModeDirty = true;
            // Show advanced params if Runtime A* or Hybrid mode selected
            if (radio.value === 'runtime' || radio.value === 'hybrid') {
                advancedParams.style.display = 'block';
            } else {
                advancedParams.style.display = 'none';
            }
        });
    });

    // Apply all config button (applies all parameters including PID, speed, and scan settings)
    document.getElementById('btn-apply-config').addEventListener('click', () => {
        sendConfig(false, false);  // Send ALL parameters (PID, speed, scan settings)
        // Don't clear dirty state immediately - wait for ROS to confirm
        // The dirty state will be cleared when we receive matching values from ROS
        // For now, just give feedback
        addLog('Config sent - waiting for confirmation...', 'info');
        setTimeout(() => alert('âš™ï¸ Configuration Applied\n\nParameters sent to controller.\n\nâš™ï¸ Configuration AppliquÃ©e\n\nParamÃ¨tres envoyÃ©s au contrÃ´leur.'), 100);
    });

    // Reset to defaults button
    document.getElementById('btn-reset-config').addEventListener('click', () => {
        if (confirm('Reset all configuration values to defaults? | RÃ©initialiser toutes les valeurs par dÃ©faut?')) {
            resetConfigToDefaults();
            setTimeout(() => alert('ðŸ”„ Configuration Reset\n\nAll values restored to defaults.\n\nðŸ”„ Configuration RÃ©initialisÃ©e\n\nToutes les valeurs restaurÃ©es par dÃ©faut.'), 100);
        }
    });

    // Initialize value displays and change indicators
    initConfigValueTracking();

    console.log('Config panel initialized');
}

// Reset configuration to default values
function resetConfigToDefaults() {
    const configInputs = [
        'cfg-kp', 'cfg-ki', 'cfg-kd',
        'cfg-base-speed', 'cfg-max-speed', 'cfg-safe-dist'
    ];

    configInputs.forEach(id => {
        const input = document.getElementById(id);
        if (input && input.dataset.default) {
            input.value = input.dataset.default;
            input.classList.remove('modified');
            dirtyInputs.delete(id);
            updateValueDisplay(input);
        }
    });

    addLog('Configuration reset to defaults | Configuration rÃ©initialisÃ©e', 'info');
}

// Initialize value tracking and displays
function initConfigValueTracking() {
    const configInputs = [
        'cfg-kp', 'cfg-ki', 'cfg-kd',
        'cfg-base-speed', 'cfg-max-speed', 'cfg-safe-dist'
    ];

    configInputs.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            // Initialize value display
            updateValueDisplay(input);

            // Track changes
            input.addEventListener('input', () => {
                const defaultValue = parseFloat(input.dataset.default);
                const currentValue = parseFloat(input.value);

                if (currentValue !== defaultValue) {
                    input.classList.add('modified');
                } else {
                    input.classList.remove('modified');
                }

                updateValueDisplay(input);
            });
        }
    });
}

// Update value display next to input
function updateValueDisplay(input) {
    const valueDisplay = input.nextElementSibling;
    if (valueDisplay && valueDisplay.classList.contains('value-display')) {
        const defaultValue = parseFloat(input.dataset.default);
        const currentValue = parseFloat(input.value);

        if (currentValue !== defaultValue) {
            valueDisplay.textContent = `(default: ${defaultValue})`;
            valueDisplay.style.color = '#ff9800';
        } else {
            valueDisplay.textContent = '';
        }
    }
}

// Clear dirty state for specified inputs
function clearDirtyInputs(inputIds) {
    inputIds.forEach(id => {
        dirtyInputs.delete(id);
        const el = document.getElementById(id);
        if (el) el.classList.remove('input-dirty');
    });
}

// Update config inputs from ROS
function updateConfigFromROS(data) {
    currentState.config = { ...currentState.config, ...data };
    
    // Only update inputs if they're not dirty (user hasn't modified them)
    const inputs = {
        'cfg-lanes': data.lanes,
        'cfg-scan-length': data.scan_length,
        'cfg-scan-width': data.scan_width,
        'cfg-kp': data.kp,
        'cfg-ki': data.ki,
        'cfg-kd': data.kd,
        'cfg-base-speed': data.base_speed,
        'cfg-max-speed': data.max_speed,
        'cfg-safe-dist': data.min_safe_distance
    };
    
    // Also update mission control inputs
    const wpInputs = {
        'wp-lanes': data.lanes,
        'wp-length': data.scan_length,
        'wp-width': data.scan_width
    };
    
    for (const [id, value] of Object.entries(inputs)) {
        const el = document.getElementById(id);
        // Don't update if input is dirty (user modified) or focused
        if (el && !dirtyInputs.has(id) && document.activeElement !== el && value !== undefined) {
            el.value = value;
        }
        // Clear dirty state if ROS value matches what we sent (confirmation)
        if (el && dirtyInputs.has(id) && parseFloat(el.value) === value) {
            dirtyInputs.delete(id);
            el.classList.remove('input-dirty');
        }
    }
    
    for (const [id, value] of Object.entries(wpInputs)) {
        const el = document.getElementById(id);
        // Don't update if input is dirty (user modified) or focused
        if (el && !dirtyInputs.has(id) && document.activeElement !== el && value !== undefined) {
            el.value = value;
        }
        // Clear dirty state if ROS value matches what we sent (confirmation)
        if (el && dirtyInputs.has(id) && parseFloat(el.value) === value) {
            dirtyInputs.delete(id);
            el.classList.remove('input-dirty');
        }
    }

    // Update navigation mode radio buttons based on A* settings (respect user edits)
    if (!navModeDirty && (data.astar_hybrid_mode !== undefined || data.astar_enabled !== undefined)) {
        let navMode = 'simple';
        if (data.astar_hybrid_mode === true) {
            navMode = 'hybrid';
        } else if (data.astar_enabled === true) {
            navMode = 'runtime';
        }
        const rb = document.getElementById(`nav-mode-${navMode}`);
        if (rb) rb.checked = true;
        const advancedParams = document.getElementById('astar-advanced-params');
        if (advancedParams) advancedParams.style.display = (navMode === 'runtime' || navMode === 'hybrid') ? 'block' : 'none';
    } else if (navModeDirty) {
        // If incoming matches current selection, clear dirty
        const current = getSelectedNavMode();
        const incoming = data.astar_hybrid_mode ? 'hybrid' : (data.astar_enabled ? 'runtime' : 'simple');
        if (current === incoming) {
            navModeDirty = false;
        }
    }

    // Update A* advanced parameters if present
    if (data.astar_resolution !== undefined) {
        const el = document.getElementById('cfg-astar-resolution');
        if (el) el.value = data.astar_resolution;
    }
    if (data.astar_safety_margin !== undefined) {
        const el = document.getElementById('cfg-astar-safety');
        if (el) el.value = data.astar_safety_margin;
    }
    if (data.astar_max_expansions !== undefined) {
        const el = document.getElementById('cfg-astar-max');
        if (el) el.value = data.astar_max_expansions;
    }

    // Update mission control UI
    updateMissionControlUI(data);
}

// Send configuration to Vostok1
function sendConfig(pidOnly = false, restart = false) {
    if (!connected || !configPublisher) {
        addLog('Not connected to ROS', 'error');
        return;
    }
    
    let config = {};
    
    if (pidOnly) {
        // Only send PID parameters
        config = {
            kp: parseFloat(document.getElementById('cfg-kp').value),
            ki: parseFloat(document.getElementById('cfg-ki').value),
            kd: parseFloat(document.getElementById('cfg-kd').value)
        };
        addLog('Sending PID config... | Envoi configuration PID...', 'info');
    } else {
        // Get selected navigation mode
        const navMode = getSelectedNavMode();

        // Send all parameters
        config = {
            lanes: parseInt(document.getElementById('cfg-lanes').value),
            scan_length: parseFloat(document.getElementById('cfg-scan-length').value),
            scan_width: parseFloat(document.getElementById('cfg-scan-width').value),
            kp: parseFloat(document.getElementById('cfg-kp').value),
            ki: parseFloat(document.getElementById('cfg-ki').value),
            kd: parseFloat(document.getElementById('cfg-kd').value),
            base_speed: parseFloat(document.getElementById('cfg-base-speed').value),
            max_speed: parseFloat(document.getElementById('cfg-max-speed').value),
            min_safe_distance: parseFloat(document.getElementById('cfg-safe-dist').value),
            // Waypoint approach parameters
            waypoint_tolerance: parseFloat(document.getElementById('cfg-waypoint-tolerance').value),
            approach_slow_distance: parseFloat(document.getElementById('cfg-approach-slow-distance').value),
            approach_slow_factor: parseFloat(document.getElementById('cfg-approach-slow-factor').value),
            // A* detour options based on selected navigation mode
            astar_enabled: (navMode === 'runtime' || navMode === 'hybrid'),
            astar_hybrid_mode: (navMode === 'hybrid'),
            hazard_enabled: (navMode === 'hybrid'),
            astar_resolution: parseFloat(document.getElementById('cfg-astar-resolution').value),
            astar_safety_margin: parseFloat(document.getElementById('cfg-astar-safety').value),
            astar_max_expansions: parseInt(document.getElementById('cfg-astar-max').value)
        };
        addLog('Sending full config... | Envoi configuration complÃ¨te...', 'info');
    }

    if (restart) {
        config.restart_mission = true;
        addLog('Restarting mission... | RedÃ©marrage de la mission...', 'warning');
    }
    
    const message = new ROSLIB.Message({
        data: JSON.stringify(config)
    });
    
    // Publish to both vostok1 and modular (sputnik) topics
    configPublisher.publish(message);
    if (modularConfigPublisher) {
        modularConfigPublisher.publish(message);
    }
    addLog('Config sent! | Configuration envoyÃ©e!', 'info');
    console.log('Config sent to both vostok1 and sputnik:', config);

    // Show success feedback toast
    if (pidOnly) {
        showFeedback(`âœ… PID: All 3 parameters applied successfully!`, 'success');
    } else {
        showFeedback(`âœ… Advanced Config: All 9 parameters applied successfully!`, 'success');
    }
}

function getSelectedNavMode() {
    const radio = document.querySelector('input[name="nav-mode"]:checked');
    return radio ? radio.value : 'simple';
}

// ========== TERMINAL OUTPUT FUNCTIONS ==========

// Add line to terminal output
function addTerminalLine(message) {
    const terminal = document.getElementById('terminal-output');
    if (!terminal) return;
    
    const line = document.createElement('div');
    line.className = 'terminal-line';
    
    // Determine log level class
    // ROS log levels: DEBUG=10, INFO=20, WARN=30, ERROR=40, FATAL=50
    let levelClass = 'info';
    let levelPrefix = '[INFO]';
    
    if (message.level !== undefined) {
        if (message.level >= 40) {
            levelClass = 'error';
            levelPrefix = '[ERROR]';
        } else if (message.level >= 30) {
            levelClass = 'warn';
            levelPrefix = '[WARN]';
        } else if (message.level <= 10) {
            levelClass = 'debug';
            levelPrefix = '[DEBUG]';
        }
    }
    
    if (message.name === 'system') {
        levelClass = 'system';
        levelPrefix = '[SYSTEM]';
    }
    
    line.classList.add(levelClass);
    
    // Format timestamp
    const now = new Date();
    const timestamp = now.toLocaleTimeString('en-US', { hour12: false });
    
    // Format the message
    const msgText = message.msg || message;
    line.innerHTML = `<span class="timestamp">[${timestamp}]</span> <span class="level">${levelPrefix}</span> <span class="message">${msgText}</span>`;
    
    terminal.appendChild(line);
    
    // Auto-scroll if enabled
    const autoScroll = document.getElementById('auto-scroll');
    if (autoScroll && autoScroll.checked) {
        terminal.scrollTop = terminal.scrollHeight;
    }
    
    // Limit lines to prevent memory issues
    while (terminal.children.length > 200) {
        terminal.removeChild(terminal.firstChild);
    }

    // World info if available
    if (data.world_name) {
        currentState.world.name = data.world_name;
    }
    if (data.pollutant_sources) {
        currentState.world.hasSmoke = (data.pollutant_sources.length || 0) > 0;
    }
    updateWorldBanner(currentState.world.name, currentState.world.hasSmoke);
}

function updateWorldFromConfig(data) {
    if (data.world_name) {
        currentState.world.name = data.world_name;
    }
    if (data.pollutant_sources) {
        currentState.world.hasSmoke = (data.pollutant_sources.length || 0) > 0;
    }
    updateWorldBanner(currentState.world.name, currentState.world.hasSmoke);
}
// Initialize terminal controls
function initTerminal() {
    const clearBtn = document.getElementById('btn-clear-terminal');
    if (clearBtn) {
        clearBtn.addEventListener('click', () => {
            const terminal = document.getElementById('terminal-output');
            terminal.innerHTML = '<div class="terminal-line system">[SYSTEM] Terminal cleared | Terminal effacÃ©</div>';
        });
    }

    // Clear logs button handler
    const clearLogsBtn = document.getElementById('btn-clear-logs');
    if (clearLogsBtn) {
        clearLogsBtn.addEventListener('click', () => {
            const logs = document.getElementById('logs');
            if (logs) {
                const timestamp = new Date().toLocaleTimeString();
                logs.innerHTML = `<div class="log-entry info">
                    <span class="timestamp">[${timestamp}]</span>
                    <span class="message">[SYSTEM] Logs cleared | Journaux effacÃ©s</span>
                </div>`;
            }
        });
    }
}

// ========== MISSION CONTROL FUNCTIONS ==========

// Initialize mission control panel
function initMissionControl() {
    console.log('Initializing mission control...');
    
    // Step 1: Generate Waypoints
    document.getElementById('btn-generate-waypoints').addEventListener('click', () => {
        generateWaypoints();
    });
    
    // Step 2: Confirm/Cancel Waypoints
    document.getElementById('btn-confirm-waypoints').addEventListener('click', () => {
        sendMissionCommand('confirm_waypoints');
        setTimeout(() => alert('âœ… Waypoints Confirmed\n\nRoute locked. Ready to start mission.\n\nâœ… Waypoints ConfirmÃ©s\n\nRoute verrouillÃ©e. PrÃªt Ã  dÃ©marrer la mission.'), 100);
    });

    document.getElementById('btn-cancel-waypoints').addEventListener('click', () => {
        sendMissionCommand('cancel_waypoints');
        clearWaypointPreview();
        setTimeout(() => alert('âŒ Waypoints Cancelled\n\nRoute cleared. Generate new waypoints.\n\nâŒ Waypoints AnnulÃ©s\n\nRoute effacÃ©e. GÃ©nÃ©rer de nouveaux waypoints.'), 100);
    });
    
    // Step 3: Start/Stop/Resume/Reset Mission
    document.getElementById('btn-start-mission').addEventListener('click', () => {
        sendMissionCommand('start_mission');
        setTimeout(() => alert('âœ… Mission Started\n\nThe boat will begin navigation.\n\nâœ… Mission DÃ©marrÃ©e\n\nLe bateau va commencer la navigation.'), 100);
    });

    document.getElementById('btn-stop-mission').addEventListener('click', () => {
        sendMissionCommand('stop_mission');
        // Send a second stop shortly after to ensure controllers see it (helps during anti-stuck)
        setTimeout(() => sendMissionCommand('stop_mission'), 200);
        setTimeout(() => alert('â¸ï¸ Mission Stopped\n\nNavigation paused. Use Resume to continue.\n\nâ¸ï¸ Mission ArrÃªtÃ©e\n\nNavigation en pause. Utilisez Reprendre pour continuer.'), 100);
    });

    document.getElementById('btn-resume-mission').addEventListener('click', () => {
        sendMissionCommand('resume_mission');
        setTimeout(() => alert('â–¶ï¸ Mission Resumed\n\nNavigation continuing.\n\nâ–¶ï¸ Mission Reprise\n\nNavigation en cours.'), 100);
    });
    
    document.getElementById('btn-reset-mission').addEventListener('click', () => {
        if (confirm('Reset mission and clear waypoints? | RÃ©initialiser la mission et effacer les waypoints?')) {
            sendMissionCommand('reset_mission');
            clearWaypointPreview();
            addLog('Mission reset - ready for new waypoints | PrÃªt pour nouveaux waypoints', 'warning');
            setTimeout(() => alert('ðŸ”„ Mission Reset\n\nAll waypoints cleared. Ready for new mission.\n\nðŸ”„ Mission RÃ©initialisÃ©e\n\nTous les waypoints effacÃ©s. PrÃªt pour nouvelle mission.'), 100);
        }
    });

    // Go Home - One-click return to spawn point
    document.getElementById('btn-go-home').addEventListener('click', () => {
        if (confirm('ðŸ  Go Home: The boat will navigate to its starting point. Continue? | Le bateau va naviguer vers son point de dÃ©part. Continuer?')) {
            sendMissionCommand('go_home');
            addLog('ðŸ  Go Home activated | Retour maison activÃ©', 'info');
            setTimeout(() => alert('ðŸ  Go Home Activated\n\nBoat navigating to starting position.\n\nðŸ  Retour Maison ActivÃ©\n\nBateau naviguant vers position de dÃ©part.'), 100);
        }
    });

    // Emergency Stop - Immediately halt the boat
    document.getElementById('btn-emergency-stop').addEventListener('click', () => {
        emergencyStop();
    });

    // Joystick Override
    document.getElementById('btn-joystick-enable').addEventListener('click', () => {
        sendMissionCommand('joystick_enable');
        setTimeout(() => alert('ðŸŽ® Joystick Mode Enabled\n\nAutonomous control disabled. Use keyboard teleop.\n\nðŸŽ® Mode Joystick ActivÃ©\n\nContrÃ´le autonome dÃ©sactivÃ©. Utilisez le tÃ©lÃ©opÃ©ration.'), 100);
    });

    document.getElementById('btn-joystick-disable').addEventListener('click', () => {
        sendMissionCommand('joystick_disable');
        setTimeout(() => alert('ðŸ¤– Autonomous Mode Restored\n\nJoystick override disabled.\n\nðŸ¤– Mode Autonome RestaurÃ©\n\nJoystick dÃ©sactivÃ©.'), 100);
    });
    
    console.log('Mission control initialized');
}

// Generate waypoints and update config
function generateWaypoints() {
    if (!connected || !configPublisher) {
        addLog('Not connected to ROS', 'error');
        return;
    }
    
    // Get waypoint parameters from mission control inputs
    const lanes = parseInt(document.getElementById('wp-lanes').value);
    const length = parseFloat(document.getElementById('wp-length').value);
    const width = parseFloat(document.getElementById('wp-width').value);
    
    // Update hidden config fields for compatibility
    document.getElementById('cfg-lanes').value = lanes;
    document.getElementById('cfg-scan-length').value = length;
    document.getElementById('cfg-scan-width').value = width;
    
    // Don't clear dirty state immediately - wait for ROS confirmation

    const navMode = getSelectedNavMode();

    // Send config update first
    const config = {
        lanes: lanes,
        scan_length: length,
        scan_width: width,
        // Carry A* settings to Sputnik with waypoint generation
        astar_enabled: navMode !== 'simple',
        astar_hybrid_mode: navMode === 'hybrid',
        hazard_enabled: navMode === 'hybrid',
        astar_resolution: parseFloat(document.getElementById('cfg-astar-resolution').value),
        astar_safety_margin: parseFloat(document.getElementById('cfg-astar-safety').value),
        astar_max_expansions: parseInt(document.getElementById('cfg-astar-max').value)
    };
    
    const configMsg = new ROSLIB.Message({
        data: JSON.stringify(config)
    });
    configPublisher.publish(configMsg);

    // Then send generate command
    sendMissionCommand('generate_waypoints');
    
    // Calculate and display preview info
    const totalWaypoints = lanes * 2 - 1;
    const estimatedDistance = length * lanes + width * (lanes - 1);
    document.getElementById('waypoint-count').textContent = `Waypoints: ~${totalWaypoints}`;
    document.getElementById('estimated-distance').textContent = `Distance: ~${estimatedDistance}m`;
    
    addLog(`Generating ${totalWaypoints} waypoints: ${length}m Ã— ${lanes} lanes`, 'info');
}

// Send mission command to Sputnik (modular mode)
function sendMissionCommand(command) {
    if (!connected) {
        addLog('Not connected to ROS', 'error');
        return;
    }

    // Create publisher if not exists (Sputnik only)
    if (!missionCommandPublisher) {
        missionCommandPublisher = new ROSLIB.Topic({
            ros: ros,
            name: '/sputnik/mission_command',
            messageType: 'std_msgs/String'
        });
    }

    const msg = new ROSLIB.Message({
        data: JSON.stringify({ command: command })
    });

    // Publish to Sputnik modular planner only
    missionCommandPublisher.publish(msg);
    addLog(`Mission command: ${command}`, 'info');
    console.log('Mission command sent to sputnik:', command);
}

// Emergency Stop - Immediately halt the boat
function emergencyStop() {
    if (!connected) {
        addLog('Not connected to ROS', 'error');
        return;
    }

    // Show critical warning with audio if possible
    const confirmed = confirm('ðŸš¨ EMERGENCY STOP ðŸš¨\n\nThis will IMMEDIATELY:\n- Cut all thrust to ZERO\n- Stop the mission\n- Halt the boat\n\nConfirm emergency stop?\n\nðŸš¨ ARRÃŠT D\'URGENCE ðŸš¨\n\nCela va IMMÃ‰DIATEMENT:\n- Couper toute propulsion Ã  ZÃ‰RO\n- ArrÃªter la mission\n- Immobiliser le bateau\n\nConfirmer l\'arrÃªt d\'urgence?');

    if (!confirmed) {
        addLog('Emergency stop cancelled by user', 'warning');
        return;
    }

    addLog('ðŸš¨ EMERGENCY STOP ACTIVATED | ARRÃŠT D\'URGENCE ACTIVÃ‰ ðŸš¨', 'error');
    console.error('ðŸš¨ EMERGENCY STOP ACTIVATED');

    // 1. IMMEDIATELY publish zero thrust to both thrusters (highest priority)
    const zeroThrustMsg = new ROSLIB.Message({ data: 0.0 });

    const leftThrustTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/wamv/thrusters/left/thrust',
        messageType: 'std_msgs/Float64'
    });

    const rightThrustTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/wamv/thrusters/right/thrust',
        messageType: 'std_msgs/Float64'
    });

    // Publish zero thrust multiple times to ensure it's received
    for (let i = 0; i < 5; i++) {
        setTimeout(() => {
            leftThrustTopic.publish(zeroThrustMsg);
            rightThrustTopic.publish(zeroThrustMsg);
        }, i * 100); // 0ms, 100ms, 200ms, 300ms, 400ms
    }

    // 2. Send emergency_stop command to planner
    sendMissionCommand('emergency_stop');

    // 3. Visual feedback - flash the emergency stop button
    const emergencyBtn = document.getElementById('btn-emergency-stop');
    if (emergencyBtn) {
        emergencyBtn.style.animation = 'emergency-flash 0.5s ease-in-out 6';
        setTimeout(() => {
            emergencyBtn.style.animation = '';
        }, 3000);
    }

    // 4. Log detailed emergency stop info
    addLog('Zero thrust commanded to both thrusters', 'error');
    addLog('Mission emergency stop sent to planner', 'error');
    addLog('Boat should be stopped. Verify manually before resuming.', 'warning');
}

// Update mission control UI based on state
function updateMissionControlUI(state) {
    console.log('updateMissionControlUI called with state:', state);
    missionState.state = (state.state || 'IDLE').toString().toUpperCase();
    // If no gps_ready field, assume true when connected (for testing)
    missionState.gpsReady = (state.gps_ready !== undefined) ? state.gps_ready : connected;
    missionState.missionArmed = state.mission_armed || false;
    missionState.joystickOverride = state.joystick_override || false;
    missionState.totalWaypoints = (state.total_waypoints !== undefined)
        ? state.total_waypoints
        : missionState.totalWaypoints;
    missionState.currentWaypoint = state.current_waypoint || 0;
    missionState.startLat = state.start_lat;
    missionState.startLon = state.start_lon;
    if (missionState.waypoints && missionState.waypoints.length > 0) {
        persistWaypoints();
    }
    
    // Update GPS indicator
    const gpsBadge = document.getElementById('gps-ready-badge');
    if (gpsBadge) {
        if (missionState.gpsReady) {
            gpsBadge.textContent = 'ðŸ“¡ GPS: Ready | PrÃªt';
            gpsBadge.className = 'gps-badge ready';
        } else {
            gpsBadge.textContent = 'ðŸ“¡ GPS: Waiting... | En attente...';
            gpsBadge.className = 'gps-badge not-ready';
        }
    }

    // Update state badge
    const stateBadge = document.getElementById('mission-state-badge');
    if (stateBadge) {
        const stateLabels = {
            'INIT': 'Init | Initialisation',
            'IDLE': 'Idle | En attente',
            'WAITING_CONFIRM': 'Confirm | Confirmation',
            'WAYPOINTS_PREVIEW': 'Preview | AperÃ§u',
            'READY': 'Ready | PrÃªt',
            'RUNNING': 'Running | En cours',
            'DRIVING': 'Driving | Navigation',
            'PAUSED': 'Paused | Pause',
            'JOYSTICK': 'Joystick',
            'FINISHED': 'Finished | TerminÃ©'
        };
        stateBadge.textContent = stateLabels[missionState.state] || missionState.state;
        stateBadge.className = `mission-badge ${missionState.state.toLowerCase()}`;
    }
    
    // Update button states based on mission state
    const btnGenerate = document.getElementById('btn-generate-waypoints');
    const btnConfirm = document.getElementById('btn-confirm-waypoints');
    const btnCancel = document.getElementById('btn-cancel-waypoints');
    const btnStart = document.getElementById('btn-start-mission');
    const btnStop = document.getElementById('btn-stop-mission');
    const btnResume = document.getElementById('btn-resume-mission');
    const btnJoyEnable = document.getElementById('btn-joystick-enable');
    const btnJoyDisable = document.getElementById('btn-joystick-disable');
    const btnGoHome = document.getElementById('btn-go-home');
    const hasWaypoints = (missionState.totalWaypoints || 0) > 0 || (missionState.waypoints && missionState.waypoints.length > 0);
    const resumableStates = ['PAUSED', 'STOP', 'STOPPED', 'EMERGENCY_STOP', 'PANIC'];
    const awaitingDecision = ['WAITING_CONFIRM', 'WAYPOINTS_PREVIEW'].includes(missionState.state);
    
    // Reset all buttons
    [btnGenerate, btnConfirm, btnCancel, btnStart, btnStop, btnResume, btnGoHome, btnJoyEnable, btnJoyDisable].forEach(btn => {
        if (btn) btn.disabled = true;
    });
    
    // STOP/joystick toggles only when not awaiting confirm/cancel
    if (!awaitingDecision) {
        if (btnStop) btnStop.disabled = !connected;
        if (btnJoyEnable) btnJoyEnable.disabled = !(connected && !missionState.joystickOverride);
        if (btnJoyDisable) btnJoyDisable.disabled = !(connected && missionState.joystickOverride);
    }

    // Generate allowed when connected, GPS ready, not in joystick override, and either no waypoints yet or we're in INIT/IDLE
    const canGenerate = connected && missionState.gpsReady && !missionState.joystickOverride &&
        (!hasWaypoints || ['INIT', 'IDLE'].includes(missionState.state));
    if (btnGenerate) btnGenerate.disabled = !canGenerate;

    // Confirm/Cancel only during preview/confirm stage (waypoints exist, no joystick override)
    const canDecide = awaitingDecision && hasWaypoints && !missionState.joystickOverride;
    if (btnConfirm) btnConfirm.disabled = !canDecide;
    if (btnCancel) btnCancel.disabled = !canDecide;

    // Start/Go Home allowed when waypoints exist, not in joystick override, not awaiting decision, and state is ready/paused/stop family
    const startAllowedStates = ['READY', 'PAUSED', 'STOP', 'STOPPED', 'EMERGENCY_STOP', 'PANIC', 'FINISHED', 'IDLE', 'INIT'];
    const canStart = hasWaypoints && !missionState.joystickOverride && !awaitingDecision && startAllowedStates.includes(missionState.state);
    if (btnStart) btnStart.disabled = !canStart;
    if (btnGoHome) btnGoHome.disabled = !canStart;

    // Resume allowed when paused/stop family and waypoints exist (no joystick override) and not awaiting decision
    const canResume = hasWaypoints && !missionState.joystickOverride && !awaitingDecision && resumableStates.includes(missionState.state);
    if (btnResume) btnResume.disabled = !canResume;
    
    // Update joystick status and instructions display
    const joystickStatus = document.getElementById('joystick-status');
    const joystickInstructions = document.getElementById('joystick-instructions');
    if (joystickStatus) {
        if (missionState.joystickOverride) {
            joystickStatus.classList.remove('hidden');
            if (joystickInstructions) joystickInstructions.classList.remove('hidden');
        } else {
            joystickStatus.classList.add('hidden');
            if (joystickInstructions) joystickInstructions.classList.add('hidden');
        }
    }
    
    // Update waypoint count display
    if (missionState.totalWaypoints > 0) {
        document.getElementById('waypoint-count').textContent = 
            `Waypoints: ${missionState.currentWaypoint}/${missionState.totalWaypoints}`;
    }
}

// Display waypoints on map
// fitToWaypoints: only zoom to fit when waypoints change, not on every update
function displayWaypointsOnMap(waypoints, fitToWaypoints = false) {
    // Clear existing waypoint markers
    clearWaypointPreview();
    
    if (!waypoints || waypoints.length === 0) return;
    
    // Get reference point: use mission start if available, otherwise use current boat position
    let startLat = missionState.startLat;
    let startLon = missionState.startLon;
    
    if (!startLat || !startLon) {
        // Fallback: use boat's current GPS position as reference
        // This allows waypoints to display even if config hasn't arrived yet
        startLat = currentState.gps.lat;
        startLon = currentState.gps.lon;
        
        if (!startLat || !startLon || startLat === 0) {
            // Still no reference point, can't display waypoints yet
            return;
        }
    }
    
    // Convert local coordinates to GPS
    // Handle both formats: [{x, y}] from vostok1 or [[x, y]] from sputnik
    const waypointLatLngs = waypoints.map((wp, idx) => {
        const x = Array.isArray(wp) ? wp[0] : wp.x;
        const y = Array.isArray(wp) ? wp[1] : wp.y;
        const latLng = localToGPS(x, y, startLat, startLon);
        return { lat: latLng[0], lon: latLng[1], x: x, y: y, idx: idx };
    });
    
    // Create waypoint markers
    waypointLatLngs.forEach((wp, idx) => {
        // Note: missionState.currentWaypoint is 1-indexed (from planner), but idx is 0-indexed
        // Default to 0 if not yet initialized (after page refresh)
        const currentWpIndex = (missionState.currentWaypoint || 1) - 1;
        const isCurrentTarget = idx === currentWpIndex;
        const isPassed = idx < currentWpIndex;
        
        const markerColor = isPassed ? 'green' : (isCurrentTarget ? 'orange' : 'blue');
        const markerSize = isCurrentTarget ? 14 : 10;
        const statusText = isPassed ? 'âœ“ Passed | PassÃ©' : (isCurrentTarget ? 'â†’ Target | Cible' : 'Pending | En attente');
        
        const icon = L.divIcon({
            className: 'waypoint-marker',
            html: `<div style="
                background-color: ${markerColor};
                width: ${markerSize}px;
                height: ${markerSize}px;
                border-radius: 50%;
                border: 2px solid white;
                box-shadow: 0 0 4px rgba(0,0,0,0.5);
                cursor: pointer;
            "></div>`,
            iconSize: [markerSize, markerSize],
            iconAnchor: [markerSize/2, markerSize/2]
        });
        
        // Detailed tooltip content
        const tooltipContent = `
            <div class="waypoint-tooltip">
                <strong>Waypoint ${idx + 1}/${waypoints.length}</strong><br>
                <span class="wp-status" style="color: ${markerColor}">${statusText}</span>
                <hr style="margin: 4px 0; border-color: #ddd;">
                <b>Local:</b> (${wp.x.toFixed(1)}, ${wp.y.toFixed(1)}) m<br>
                <b>GPS:</b> ${wp.lat.toFixed(6)}Â°, ${wp.lon.toFixed(6)}Â°
            </div>
        `;
        
        const marker = L.marker([wp.lat, wp.lon], { icon: icon })
            .bindTooltip(tooltipContent, {
                permanent: false,  // Only show on hover
                direction: 'top',
                offset: [0, -10],
                className: 'waypoint-tooltip-container',
                sticky: true  // Keeps tooltip visible while mouse hovers over waypoint
            })
            .addTo(map);
        
        waypointMarkers.push(marker);
    });
    
    // Draw path line connecting waypoints
    const pathCoords = waypointLatLngs.map(wp => [wp.lat, wp.lon]);
    waypointPath = L.polyline(pathCoords, {
        color: '#3388ff',
        weight: 2,
        opacity: 0.7,
        dashArray: '5, 10'
    }).addTo(map);
    
    // Fit map to show all waypoints (only when waypoints change, not on every update)
    if (fitToWaypoints && pathCoords.length > 0) {
        const bounds = L.latLngBounds(pathCoords);
        bounds.extend([startLat, startLon]);  // Include boat position
        map.fitBounds(bounds, { padding: [50, 50] });
    }
    
    addLog(`Displayed ${waypoints.length} waypoints on map`, 'info');
}

// Clear waypoint preview from map
function clearWaypointPreview() {
    waypointMarkers.forEach(marker => map.removeLayer(marker));
    waypointMarkers = [];
    
    if (waypointPath) {
        map.removeLayer(waypointPath);
        waypointPath = null;
    }
}

function clearPollutantMarkers() {
    pollutantMarkers.forEach(marker => map.removeLayer(marker));
    pollutantMarkers = [];
}

// Clear stored waypoints + UI affordances
function clearWaypoints(reason = '') {
    missionState.waypoints = [];
    missionState.totalWaypoints = 0;
    missionState.currentWaypoint = 0;
    clearWaypointPreview();

    const wpCount = document.getElementById('waypoint-count');
    if (wpCount) wpCount.textContent = 'Waypoints: 0';
    const distEstimate = document.getElementById('estimated-distance');
    if (distEstimate) distEstimate.textContent = 'Distance: 0m';

    if (reason) {
        addLog(`Waypoints cleared (${reason})`, 'warning');
    }

    try {
        localStorage.removeItem(WAYPOINT_STORAGE_KEY);
    } catch (err) {
        console.warn('Failed to clear waypoint cache', err);
    }
}

function persistWaypoints() {
    try {
        const payload = {
            waypoints: missionState.waypoints || [],
            totalWaypoints: missionState.totalWaypoints || 0,
            startLat: missionState.startLat,
            startLon: missionState.startLon
        };
        localStorage.setItem(WAYPOINT_STORAGE_KEY, JSON.stringify(payload));
    } catch (err) {
        console.warn('Failed to persist waypoints', err);
    }
}

function restorePersistedWaypoints() {
    try {
        const raw = localStorage.getItem(WAYPOINT_STORAGE_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (data.waypoints && data.waypoints.length > 0) {
            missionState.waypoints = data.waypoints;
            missionState.totalWaypoints = data.totalWaypoints || data.waypoints.length;
            missionState.startLat = data.startLat || missionState.startLat;
            missionState.startLon = data.startLon || missionState.startLon;
            addLog(`Restored ${missionState.waypoints.length} cached waypoints`, 'info');
            displayWaypointsOnMap(missionState.waypoints, true);
        }
    } catch (err) {
        console.warn('Failed to restore waypoint cache', err);
    }
}

// Convert local ENU coordinates to GPS
function localToGPS(x, y, refLat, refLon) {
    const R = 6371000.0;  // Earth radius in meters
    const refLatRad = refLat * Math.PI / 180;

    // x = East, y = North
    const dLat = y / R;
    const dLon = x / (R * Math.cos(refLatRad));

    const lat = refLat + dLat * 180 / Math.PI;
    const lon = refLon + dLon * 180 / Math.PI;

    return [lat, lon];
}

// Update pollutant sources (smoke generators) on minimap
function updatePollutantSources(sources) {
    // Clear existing pollutant markers
    pollutantMarkers.forEach(marker => map.removeLayer(marker));
    pollutantMarkers = [];

    if (!sources || sources.length === 0) {
        return;
    }

    // Get reference point for coordinate conversion
    let refLat = missionState.startLat || currentState.gps.lat;
    let refLon = missionState.startLon || currentState.gps.lon;

    if (!refLat || !refLon || refLat === 0) {
        // No reference point yet, skip display
        return;
    }

    // Create markers for each pollutant source
    sources.forEach((source, idx) => {
        try {
            const sourceName = source.name || `Pollutant ${idx + 1}`;
            const localPos = source.local || [0, 0];
            const worldPos = source.world || [0, 0, 0];
            const x = localPos[0];
            const y = localPos[1];

            // Convert local coordinates to GPS
            const [lat, lon] = localToGPS(x, y, refLat, refLon);

            // Create pollutant marker icon (smoke/warning symbol)
            const icon = L.divIcon({
                className: 'pollutant-marker',
                html: `<div style="
                    background-color: #ff6b6b;
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    border: 3px solid #8b0000;
                    box-shadow: 0 0 8px rgba(255, 107, 107, 0.8);
                    cursor: pointer;
                    position: relative;
                ">
                    <span style="position: absolute; font-size: 20px; left: -2px; top: -6px;">ðŸŒ«ï¸</span>
                </div>`,
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });

            // Tooltip content
            const tooltipContent = `
                <div class="pollutant-tooltip" style="max-width: 200px;">
                    <strong>ðŸŒ«ï¸ ${sourceName}</strong><br>
                    <hr style="margin: 4px 0; border-color: #ddd;">
                    <b>Local:</b> (${x.toFixed(1)}, ${y.toFixed(1)}) m<br>
                    <b>GPS:</b> ${lat.toFixed(6)}Â°, ${lon.toFixed(6)}Â°<br>
                    <b>World:</b> (${worldPos[0].toFixed(1)}, ${worldPos[1].toFixed(1)})
                </div>
            `;

            // Create and add marker
            const marker = L.marker([lat, lon], { icon: icon })
                .bindTooltip(tooltipContent, {
                    permanent: false,
                    direction: 'top',
                    offset: [0, -10],
                    className: 'pollutant-tooltip-container',
                    sticky: true
                })
                .addTo(map);

            pollutantMarkers.push(marker);
        } catch (e) {
            console.warn(`Failed to display pollutant source ${idx}:`, e);
        }
    });

    addLog(`Displayed ${sources.length} pollutant sources on map | Affichage de ${sources.length} sources de polluants sur la carte`, 'info');
}

// Update UI status panel for pollutant sources/smoke generators
function updatePollutantStatusUI(count, status, sources) {
    const statusEl = document.getElementById('pollutant-status');
    const countEl = document.getElementById('pollutant-count');
    const listEl = document.getElementById('pollutant-list');

    if (!statusEl || !countEl || !listEl) return;

    // Update count display
    if (count > 0) {
        countEl.textContent = `${count} source${count !== 1 ? 's' : ''} detected | dÃ©tectÃ©${count !== 1 ? 's' : ''}`;
    } else {
        countEl.textContent = '0 sources';
    }

    // Update status badge and list
    if (status === 'detected' && count > 0) {
        statusEl.textContent = `âœ… DETECTED | DÃ‰TECTÃ‰ (${count})`;
        statusEl.className = 'value badge';
        statusEl.style.backgroundColor = '#2ecc71';
        statusEl.style.color = '#fff';

        // Build source list
        if (sources && sources.length > 0) {
            let listHtml = '<strong>Detected Sources:</strong><br>';
            sources.forEach((src, idx) => {
                const name = src.name || `Smoke Generator ${idx + 1}`;
                const localX = (src.local ? src.local[0] : 0).toFixed(1);
                const localY = (src.local ? src.local[1] : 0).toFixed(1);
                listHtml += `<span style="display: block; margin: 4px 0;">ðŸŒ«ï¸ [${idx + 1}] ${name}</span>`;
                listHtml += `<span style="display: block; margin-left: 20px; font-size: 0.85em; color: #999;">Local: (${localX}, ${localY})m</span>`;
            });
            listEl.innerHTML = listHtml;
        }
    } else if (status === 'none' || count === 0) {
        statusEl.textContent = 'âœ… NONE | AUCUNE';
        statusEl.className = 'value badge';
        statusEl.style.backgroundColor = '#3498db';
        statusEl.style.color = '#fff';
        listEl.innerHTML = '<span style="color: #aaa; font-style: italic;">World loaded without smoke generators | Monde chargÃ© sans gÃ©nÃ©rateurs de fumÃ©e</span>';
    } else {
        statusEl.textContent = 'â³ Scanning... | Analyse...';
        statusEl.className = 'value badge';
        statusEl.style.backgroundColor = '#95a5a6';
        statusEl.style.color = '#fff';
        listEl.innerHTML = '';
    }
}

// Update LiDAR Smoke Detection UI (v2.2)
function updateSmokeDetection(data) {
    const statusEl = document.getElementById('smoke-detection-status');
    const distanceEl = document.getElementById('smoke-distance');
    const pointsEl = document.getElementById('smoke-points');
    const spreadEl = document.getElementById('smoke-spread');
    const locationEl = document.getElementById('smoke-location');

    if (!statusEl || !distanceEl || !pointsEl || !spreadEl || !locationEl) return;

    if (data.detected) {
        // Smoke detected!
        statusEl.textContent = 'ðŸŒ«ï¸ SMOKE DETECTED';
        statusEl.className = 'value badge';
        statusEl.style.backgroundColor = '#ff6b6b';
        statusEl.style.color = '#fff';
        statusEl.style.fontWeight = 'bold';

        distanceEl.textContent = `${data.distance.toFixed(1)}m`;
        pointsEl.textContent = `${data.point_count} pts`;

        // Show horizontal/vertical spread ratio
        const hSpread = data.horizontal_spread || 0;
        const vSpread = data.vertical_spread || 0;
        spreadEl.textContent = `${hSpread.toFixed(1)}m / ${vSpread.toFixed(1)}m`;
        spreadEl.style.color = (hSpread > vSpread * 0.8) ? '#2ecc71' : '#e74c3c';

        locationEl.textContent = `(${data.center_x.toFixed(1)}, ${data.center_y.toFixed(1)})`;

        // Log to terminal
        addTerminalLine({
            level: 30,
            msg: `ðŸŒ«ï¸ SMOKE DETECTED: ${data.point_count} pts at ${data.distance.toFixed(1)}m (H=${hSpread.toFixed(1)}m, V=${vSpread.toFixed(1)}m)`,
            name: 'smoke_detection'
        });

        // Optional: Add smoke marker to map if boat position is known
        if (currentState.gps && currentState.gps.latitude && currentState.gps.longitude) {
            // Calculate smoke position in world coordinates
            // (This would require transformation from local to GPS)
            // For now, just log the detection
        }
    } else {
        // No smoke detected
        statusEl.textContent = 'âœ“ No smoke';
        statusEl.className = 'value badge';
        statusEl.style.backgroundColor = '#2ecc71';
        statusEl.style.color = '#fff';
        statusEl.style.fontWeight = 'normal';

        distanceEl.textContent = '-';
        pointsEl.textContent = '0';
        spreadEl.textContent = '-';
        spreadEl.style.color = '';
        locationEl.textContent = '-';
    }
}

// =============================================================================
// PERCEPTION & CONTROL TUNING SYSTEM
// =============================================================================

// Preset configurations
const TUNING_PRESETS = {
    universal: {
        name: "Universal",
        oko: {
            min_height: -1.8,
            max_height: 0.8,
            min_range: 0.8,
            max_range: 80.0,
            min_safe_distance: 11.0,
            critical_distance: 3.5,
            cluster_distance: 1.5,
            min_cluster_size: 4,
            temporal_history_size: 3,
            temporal_threshold: 3,
            water_plane_threshold: 0.2,
            hysteresis_distance: 1.3,
            // Smoke detection (v2.1) - Tuned for sydney_regatta_smoke.sdf
            smoke_filter_enabled: true,
            smoke_min_height: 0.3,
            smoke_max_height: 10.0,
            solid_min_height: -2.0,
            solid_max_height: 0.5
        },
        buran: {
            critical_distance: 3.5,
            min_safe_distance: 11.0,
            bank_slow_distance: 7.0,
            obstacle_slow_factor: 0.35,
            bank_slow_factor: 0.22,
            avoid_diff_gain: 35.0,
            use_vfh_bias: true,
            max_avoidance_turn_deg: 20.0,
            stuck_timeout: 3.5,
            stuck_threshold: 0.9,
            reverse_timeout: 2.5,
            max_reverse_distance: 20.0,
            turn_deadband_deg: 1.5,
            slew_rate_limit: 90.0
        }
    },
    buoyField: {
        name: "Buoy Field",
        oko: {
            min_height: -1.8,
            max_height: 0.8,
            min_range: 0.8,
            max_range: 80.0,
            min_safe_distance: 10.0,
            critical_distance: 2.5,
            cluster_distance: 1.2,
            min_cluster_size: 3,
            temporal_history_size: 2,
            temporal_threshold: 2,
            water_plane_threshold: 0.2,
            hysteresis_distance: 1.0,
            // Smoke detection (v2.1) - Aggressive filtering for clustered buoys
            smoke_filter_enabled: true,
            smoke_min_height: 0.3,
            smoke_max_height: 10.0,
            solid_min_height: -2.0,
            solid_max_height: 0.6
        },
        buran: {
            critical_distance: 3.0,
            min_safe_distance: 10.0,
            bank_slow_distance: 6.0,
            obstacle_slow_factor: 0.3,
            bank_slow_factor: 0.2,
            avoid_diff_gain: 40.0,
            use_vfh_bias: true,
            max_avoidance_turn_deg: 25.0,
            stuck_timeout: 3.0,
            stuck_threshold: 1.0,
            no_go_zone_radius: 6.0,
            detour_distance: 8.0,
            reverse_timeout: 2.0,
            max_reverse_distance: 10.0,
            turn_deadband_deg: 1.0,
            slew_rate_limit: 100.0
        }
    },
    pier: {
        name: "Pier Detect",
        oko: {
            min_height: -1.6,
            max_height: 1.0,
            min_range: 0.5,
            max_range: 60.0,
            min_safe_distance: 12.0,
            critical_distance: 2.0,
            cluster_distance: 0.5,
            min_cluster_size: 3,
            temporal_history_size: 3,
            temporal_threshold: 2,
            water_plane_threshold: 0.15,
            hysteresis_distance: 1.5,
            // Smoke detection (v2.1) - Detect low piers
            smoke_filter_enabled: true,
            smoke_min_height: 0.3,
            smoke_max_height: 10.0,
            solid_min_height: -2.0,
            solid_max_height: 0.8
        },
        buran: {
            critical_distance: 2.5,
            min_safe_distance: 12.0,
            bank_slow_distance: 8.0,
            obstacle_slow_factor: 0.3,
            bank_slow_factor: 0.2,
            avoid_diff_gain: 30.0,
            use_vfh_bias: true,
            max_avoidance_turn_deg: 15.0,
            stuck_timeout: 4.0,
            stuck_threshold: 0.8,
            no_go_zone_radius: 10.0,
            detour_distance: 15.0,
            reverse_timeout: 3.0,
            max_reverse_distance: 25.0,
            turn_deadband_deg: 2.0,
            slew_rate_limit: 80.0
        }
    },
    openWater: {
        name: "Open Water",
        oko: {
            min_height: -0.2,
            max_height: 3.0,
            min_range: 3.0,
            max_range: 80.0,
            min_safe_distance: 15.0,
            critical_distance: 5.0,
            cluster_distance: 3.0,
            min_cluster_size: 6,
            temporal_history_size: 2,
            temporal_threshold: 1,
            water_plane_threshold: 0.5,
            hysteresis_distance: 2.0,
            // Smoke detection (v2.1) - Conservative for open water
            smoke_filter_enabled: false,  // Disabled for open water
            smoke_min_height: 0.3,
            smoke_max_height: 10.0,
            solid_min_height: -2.0,
            solid_max_height: 0.5
        },
        buran: {
            critical_distance: 5.0,
            min_safe_distance: 15.0,
            bank_slow_distance: 8.0,
            obstacle_slow_factor: 0.4,
            bank_slow_factor: 0.3,
            avoid_diff_gain: 30.0,
            use_vfh_bias: true,
            max_avoidance_turn_deg: 15.0,
            stuck_timeout: 4.0,
            stuck_threshold: 0.8,
            no_go_zone_radius: 10.0,
            detour_distance: 15.0,
            reverse_timeout: 3.0,
            max_reverse_distance: 30.0,
            turn_deadband_deg: 2.0,
            slew_rate_limit: 80.0
        }
    }
};

// Initialize tuning panel
function initTuningPanel() {
    console.log('Initializing tuning panel...');

    // Collapsible section headers
    document.querySelectorAll('.tuning-section-header').forEach(header => {
        header.addEventListener('click', function() {
            const targetId = this.getAttribute('data-target');
            const content = document.getElementById(targetId);
            const icon = this.querySelector('.section-icon');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = 'â–¼';
            } else {
                content.style.display = 'none';
                icon.textContent = 'â–¶';
            }
        });
    });

    // Preset buttons
    document.getElementById('btn-preset-universal').addEventListener('click', () => applyPreset('universal'));
    document.getElementById('btn-preset-buoy-field').addEventListener('click', () => applyPreset('buoyField'));
    document.getElementById('btn-preset-pier').addEventListener('click', () => applyPreset('pier'));
    document.getElementById('btn-preset-open-water').addEventListener('click', () => applyPreset('openWater'));

    // Apply buttons
    document.getElementById('btn-apply-oko').addEventListener('click', () => applyOkoParameters());
    document.getElementById('btn-apply-buran').addEventListener('click', () => applyBuranParameters());

    console.log('Tuning panel initialized');
}

// Apply preset configuration
function applyPreset(presetName) {
    const preset = TUNING_PRESETS[presetName];
    if (!preset) {
        addLog(`Preset ${presetName} not found`, 'error');
        return;
    }

    const statusEl = document.getElementById('preset-status');
    statusEl.textContent = `Applying ${preset.name} preset...`;
    statusEl.style.color = '#f39c12';

    // Update UI inputs
    updateOkoInputs(preset.oko);
    updateBuranInputs(preset.buran);

    // Apply parameters to ROS
    applyOkoParameters(preset.oko);
    applyBuranParameters(preset.buran);

    setTimeout(() => {
        statusEl.textContent = `âœ… ${preset.name} preset applied!`;
        statusEl.style.color = '#27ae60';
        setTimeout(() => {
            statusEl.textContent = '';
        }, 3000);
    }, 500);

    addLog(`Applied ${preset.name} preset`, 'info');
}

// Update OKO input fields from preset
function updateOkoInputs(params) {
    document.getElementById('oko-min-height').value = params.min_height;
    document.getElementById('oko-max-height').value = params.max_height;
    document.getElementById('oko-min-range').value = params.min_range;
    document.getElementById('oko-max-range').value = params.max_range;
    document.getElementById('oko-safe-dist').value = params.min_safe_distance;
    document.getElementById('oko-critical-dist').value = params.critical_distance;
    document.getElementById('oko-cluster-dist').value = params.cluster_distance;
    document.getElementById('oko-min-cluster-size').value = params.min_cluster_size;
    document.getElementById('oko-temporal-history').value = params.temporal_history_size;
    document.getElementById('oko-temporal-threshold').value = params.temporal_threshold;
    document.getElementById('oko-water-threshold').value = params.water_plane_threshold;
    document.getElementById('oko-hysteresis').value = params.hysteresis_distance;

    // Smoke detection parameters (v2.1)
    if (params.smoke_filter_enabled !== undefined) {
        document.getElementById('oko-smoke-enabled').value = params.smoke_filter_enabled.toString();
    }
    if (params.smoke_min_height !== undefined) {
        document.getElementById('oko-smoke-min-height').value = params.smoke_min_height;
    }
    if (params.smoke_max_height !== undefined) {
        document.getElementById('oko-smoke-max-height').value = params.smoke_max_height;
    }
    if (params.solid_min_height !== undefined) {
        document.getElementById('oko-solid-min-height').value = params.solid_min_height;
    }
    if (params.solid_max_height !== undefined) {
        document.getElementById('oko-solid-max-height').value = params.solid_max_height;
    }
}

// Update BURAN input fields from preset
function updateBuranInputs(params) {
    document.getElementById('buran-critical-dist').value = params.critical_distance;
    document.getElementById('buran-safe-dist').value = params.min_safe_distance;
    document.getElementById('buran-bank-dist').value = params.bank_slow_distance;
    document.getElementById('buran-obstacle-slow').value = params.obstacle_slow_factor;
    document.getElementById('buran-bank-slow').value = params.bank_slow_factor;
    document.getElementById('buran-avoid-gain').value = params.avoid_diff_gain;
    document.getElementById('buran-use-vfh').value = params.use_vfh_bias.toString();
    if (params.max_avoidance_turn_deg !== undefined) {
        document.getElementById('buran-max-turn').value = params.max_avoidance_turn_deg;
    }
    document.getElementById('buran-stuck-timeout').value = params.stuck_timeout;
    document.getElementById('buran-stuck-threshold').value = params.stuck_threshold;
    document.getElementById('buran-reverse-timeout').value = params.reverse_timeout;
    document.getElementById('buran-max-reverse').value = params.max_reverse_distance;
    document.getElementById('buran-turn-deadband').value = params.turn_deadband_deg;
    document.getElementById('buran-slew-rate').value = params.slew_rate_limit;
}

// Apply OKO perception parameters via config topic
function applyOkoParameters(presetParams = null) {
    if (!connected || !configPublisher) {
        addLog('Not connected to ROS', 'error');
        showFeedback('âŒ Not connected to ROS', 'error');
        return;
    }

    // Get parameters from UI or preset
    const params = presetParams || {
        min_height: parseFloat(document.getElementById('oko-min-height').value),
        max_height: parseFloat(document.getElementById('oko-max-height').value),
        min_range: parseFloat(document.getElementById('oko-min-range').value),
        max_range: parseFloat(document.getElementById('oko-max-range').value),
        min_safe_distance: parseFloat(document.getElementById('oko-safe-dist').value),
        critical_distance: parseFloat(document.getElementById('oko-critical-dist').value),
        cluster_distance: parseFloat(document.getElementById('oko-cluster-dist').value),
        min_cluster_size: parseInt(document.getElementById('oko-min-cluster-size').value),
        temporal_history_size: parseInt(document.getElementById('oko-temporal-history').value),
        temporal_threshold: parseInt(document.getElementById('oko-temporal-threshold').value),
        water_plane_threshold: parseFloat(document.getElementById('oko-water-threshold').value),
        hysteresis_distance: parseFloat(document.getElementById('oko-hysteresis').value),
        // Smoke detection parameters (v2.1)
        smoke_filter_enabled: document.getElementById('oko-smoke-enabled') ?
            (document.getElementById('oko-smoke-enabled').value === 'true') : true,
        smoke_min_height: document.getElementById('oko-smoke-min-height') ?
            parseFloat(document.getElementById('oko-smoke-min-height').value) : 0.3,
        smoke_max_height: document.getElementById('oko-smoke-max-height') ?
            parseFloat(document.getElementById('oko-smoke-max-height').value) : 10.0,
        solid_min_height: document.getElementById('oko-solid-min-height') ?
            parseFloat(document.getElementById('oko-solid-min-height').value) : -2.0,
        solid_max_height: document.getElementById('oko-solid-max-height') ?
            parseFloat(document.getElementById('oko-solid-max-height').value) : 0.5
    };

    // Publish to /sputnik/set_config topic (same as BURAN)
    const message = new ROSLIB.Message({
        data: JSON.stringify(params)
    });

    configPublisher.publish(message);

    const totalParams = Object.keys(params).length;
    addLog(`âœ… OKO: ${totalParams} parameters sent via config topic`, 'info');
    showFeedback(`âœ… OKO: All ${totalParams} parameters applied successfully!`, 'success');
    console.log('OKO config sent to /sputnik/set_config:', params);
}

// Apply BURAN controller parameters via config topic
function applyBuranParameters(presetParams = null) {
    if (!connected || !configPublisher) {
        addLog('Not connected to ROS', 'error');
        showFeedback('âŒ Not connected to ROS', 'error');
        return;
    }

    // Get parameters from UI or preset
    const params = presetParams || {
        critical_distance: parseFloat(document.getElementById('buran-critical-dist').value),
        min_safe_distance: parseFloat(document.getElementById('buran-safe-dist').value),
        bank_slow_distance: parseFloat(document.getElementById('buran-bank-dist').value),
        obstacle_slow_factor: parseFloat(document.getElementById('buran-obstacle-slow').value),
        bank_slow_factor: parseFloat(document.getElementById('buran-bank-slow').value),
        avoid_diff_gain: parseFloat(document.getElementById('buran-avoid-gain').value),
        use_vfh_bias: document.getElementById('buran-use-vfh').value === 'true',
        max_avoidance_turn_deg: parseFloat(document.getElementById('buran-max-turn').value),
        stuck_timeout: parseFloat(document.getElementById('buran-stuck-timeout').value),
        stuck_threshold: parseFloat(document.getElementById('buran-stuck-threshold').value),
        reverse_timeout: parseFloat(document.getElementById('buran-reverse-timeout').value),
        max_reverse_distance: parseFloat(document.getElementById('buran-max-reverse').value),
        turn_deadband_deg: parseFloat(document.getElementById('buran-turn-deadband').value),
        slew_rate_limit: parseFloat(document.getElementById('buran-slew-rate').value)
    };

    // Publish to /sputnik/set_config topic (same as basic config)
    const message = new ROSLIB.Message({
        data: JSON.stringify(params)
    });

    configPublisher.publish(message);

    const totalParams = Object.keys(params).length;
    addLog(`âœ… BURAN: ${totalParams} parameters sent via config topic`, 'info');
    showFeedback(`âœ… BURAN: All ${totalParams} parameters applied successfully!`, 'success');
    console.log('BURAN config sent to /sputnik/set_config:', params);
}

// Show visual feedback toast notification
function showFeedback(message, type = 'info') {
    // Create toast container if it doesn't exist
    let toastContainer = document.getElementById('toast-container');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toast-container';
        toastContainer.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        document.body.appendChild(toastContainer);
    }

    // Create toast element
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;

    // Set colors based on type
    let bgColor, borderColor;
    switch (type) {
        case 'success':
            bgColor = 'rgba(40, 167, 69, 0.95)';
            borderColor = '#28a745';
            break;
        case 'error':
            bgColor = 'rgba(220, 53, 69, 0.95)';
            borderColor = '#dc3545';
            break;
        case 'warning':
            bgColor = 'rgba(255, 193, 7, 0.95)';
            borderColor = '#ffc107';
            break;
        default: // info
            bgColor = 'rgba(23, 162, 184, 0.95)';
            borderColor = '#17a2b8';
    }

    toast.style.cssText = `
        background: ${bgColor};
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        border-left: 4px solid ${borderColor};
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        min-width: 300px;
        max-width: 400px;
        font-size: 14px;
        font-weight: 500;
        line-height: 1.5;
        animation: slideIn 0.3s ease-out;
        white-space: pre-wrap;
    `;

    toast.textContent = message;
    toastContainer.appendChild(toast);

    // Auto-remove after delay
    const duration = type === 'error' || type === 'warning' ? 5000 : 3000;
    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease-in';
        setTimeout(() => {
            toast.remove();
            // Remove container if empty
            if (toastContainer.children.length === 0) {
                toastContainer.remove();
            }
        }, 300);
    }, duration);
}

// Set ROS2 parameter via rosbridge service call
function setROS2Parameter(nodeName, paramName, paramValue, callback) {
    // Create service client for set_parameters
    const setParamsService = new ROSLIB.Service({
        ros: ros,
        name: `${nodeName}/set_parameters`,
        serviceType: 'rcl_interfaces/srv/SetParameters'
    });

    // Determine parameter type
    let paramType;
    let value;

    if (typeof paramValue === 'boolean') {
        paramType = 1; // PARAMETER_BOOL
        value = { bool_value: paramValue };
    } else if (Number.isInteger(paramValue)) {
        paramType = 2; // PARAMETER_INTEGER
        value = { integer_value: paramValue };
    } else if (typeof paramValue === 'number') {
        paramType = 3; // PARAMETER_DOUBLE
        value = { double_value: paramValue };
    } else if (typeof paramValue === 'string') {
        paramType = 4; // PARAMETER_STRING
        value = { string_value: paramValue };
    } else {
        console.error(`Unknown parameter type for ${paramName}:`, typeof paramValue);
        if (callback) callback(false);
        return;
    }

    // Create request
    const request = new ROSLIB.ServiceRequest({
        parameters: [{
            name: paramName,
            value: {
                type: paramType,
                ...value
            }
        }]
    });

    // Call service
    setParamsService.callService(request, (response) => {
        if (response && response.results && response.results.length > 0) {
            const result = response.results[0];
            if (result.successful) {
                console.log(`âœ… Set ${nodeName}/${paramName} = ${paramValue}`);
                if (callback) callback(true);
            } else {
                console.error(`âŒ Failed to set ${nodeName}/${paramName}: ${result.reason}`);
                if (callback) callback(false);
            }
        } else {
            console.error(`âŒ No response from ${nodeName}/set_parameters`);
            if (callback) callback(false);
        }
    }, (error) => {
        console.error(`âŒ Service call failed for ${nodeName}/${paramName}:`, error);
        if (callback) callback(false);
    });
}

// Hook into existing page load initialization
// Find the existing initConfigPanel call and add initTuningPanel after it
const originalInit = window.onload;
window.addEventListener('load', () => {
    // Wait for ROS connection before initializing tuning panel
    setTimeout(() => {
        if (connected) {
            initTuningPanel();
        } else {
            // Retry after connection established
            const checkConnection = setInterval(() => {
                if (connected) {
                    initTuningPanel();
                    clearInterval(checkConnection);
                }
            }, 1000);
        }
    }, 1000);
});

// =============================================================================
// PHASE 2: MISSION HISTORY LOG, WAYPOINT VALIDATION, PROGRESS BAR
// =============================================================================

// Mission History System
const missionHistory = [];
const MAX_HISTORY_ENTRIES = 100;
let historyExpanded = false;
let historyUpdatePending = false;
let lastHistoryUpdate = 0;
const HISTORY_UPDATE_THROTTLE = 500; // Update display max once per 500ms

// Initialize mission history
function initMissionHistory() {
    // Toggle history panel
    document.getElementById('btn-toggle-history').addEventListener('click', () => {
        historyExpanded = !historyExpanded;
        const content = document.getElementById('mission-history-content');
        const icon = document.querySelector('.history-icon');

        if (historyExpanded) {
            content.style.display = 'block';
            icon.textContent = 'â–¼';
        } else {
            content.style.display = 'none';
            icon.textContent = 'â–¶';
        }
    });

    // Clear history
    document.getElementById('btn-clear-history').addEventListener('click', () => {
        if (confirm('Clear all mission history? | Effacer tout l\'historique?')) {
            missionHistory.length = 0;
            updateHistoryDisplay();
            addLog('Mission history cleared', 'info');
        }
    });

    // Export history as JSON
    document.getElementById('btn-export-history').addEventListener('click', () => {
        exportHistoryAsJSON();
    });

    console.log('Mission history initialized');
}

// Add event to mission history
function addHistoryEvent(type, message, data = {}) {
    const event = {
        timestamp: new Date().toISOString(),
        time: new Date().toLocaleTimeString(),
        type: type, // 'state', 'waypoint', 'detour', 'sass', 'emergency', 'info', 'warning', 'error'
        message: message,
        data: data
    };

    missionHistory.unshift(event); // Add to beginning

    // Keep only last MAX_HISTORY_ENTRIES
    if (missionHistory.length > MAX_HISTORY_ENTRIES) {
        missionHistory.pop();
    }

    // Throttle display updates to prevent rapid flickering
    scheduleHistoryUpdate();
}

// Schedule a throttled history display update
function scheduleHistoryUpdate() {
    const now = Date.now();

    // If enough time has passed since last update, update immediately
    if (now - lastHistoryUpdate >= HISTORY_UPDATE_THROTTLE) {
        updateHistoryDisplay();
        lastHistoryUpdate = now;
        historyUpdatePending = false;
    } else if (!historyUpdatePending) {
        // Schedule an update for later
        historyUpdatePending = true;
        setTimeout(() => {
            updateHistoryDisplay();
            lastHistoryUpdate = Date.now();
            historyUpdatePending = false;
        }, HISTORY_UPDATE_THROTTLE - (now - lastHistoryUpdate));
    }
}

// Update history display in UI
function updateHistoryDisplay() {
    const logEl = document.getElementById('mission-history-log');
    const countEl = document.getElementById('history-count');

    if (!logEl || !countEl) return;

    countEl.textContent = `(${missionHistory.length} events)`;

    if (missionHistory.length === 0) {
        logEl.innerHTML = '<div class="history-empty">No events yet | Aucun Ã©vÃ©nement</div>';
        return;
    }

    let html = '';
    missionHistory.forEach(event => {
        const iconMap = {
            'state': 'ðŸ”„',
            'waypoint': 'ðŸ“',
            'detour': 'âš ï¸',
            'sass': 'ðŸ”„',
            'emergency': 'ðŸš¨',
            'info': 'â„¹ï¸',
            'warning': 'âš ï¸',
            'error': 'âŒ'
        };
        const icon = iconMap[event.type] || 'â€¢';
        const className = `history-entry history-${event.type}`;

        html += `<div class="${className}">
            <span class="history-time">${event.time}</span>
            <span class="history-icon">${icon}</span>
            <span class="history-message">${event.message}</span>
        </div>`;
    });

    logEl.innerHTML = html;

    // Auto-scroll to top if expanded
    if (historyExpanded) {
        logEl.scrollTop = 0;
    }
}

// Export history as JSON
function exportHistoryAsJSON() {
    const dataStr = JSON.stringify(missionHistory, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `mission_history_${new Date().toISOString()}.json`;
    link.click();
    URL.revokeObjectURL(url);
    addLog('Mission history exported', 'info');
}

// Waypoint Validation System
let currentValidation = null;

// Validate waypoints before confirmation
async function validateWaypoints(waypoints) {
    if (!waypoints || waypoints.length === 0) {
        return null;
    }

    const validation = {
        timestamp: Date.now(),
        waypoints: waypoints,
        checks: {
            reachable: { pass: true, message: 'âœ… All waypoints reachable' },
            obstacles: { pass: true, message: 'âœ… No waypoints in known obstacles', warnings: [] },
            smoke: { pass: true, message: 'âœ… Path clear of smoke zones', warnings: [] },
            proximity: { pass: true, message: 'âœ… Safe clearance from obstacles', warnings: [] }
        },
        estimates: {
            distance: 0,
            duration: 0
        }
    };

    // Calculate total distance
    let totalDistance = 0;
    for (let i = 0; i < waypoints.length - 1; i++) {
        const wp1 = Array.isArray(waypoints[i]) ? waypoints[i] : [waypoints[i].x, waypoints[i].y];
        const wp2 = Array.isArray(waypoints[i + 1]) ? waypoints[i + 1] : [waypoints[i + 1].x, waypoints[i + 1].y];
        const dx = wp2[0] - wp1[0];
        const dy = wp2[1] - wp1[1];
        totalDistance += Math.sqrt(dx * dx + dy * dy);
    }
    validation.estimates.distance = totalDistance;

    // Estimate duration (assuming average speed from config or default)
    const avgSpeed = currentState.config.base_speed ? currentState.config.base_speed / 200 : 2.5; // m/s
    validation.estimates.duration = totalDistance / avgSpeed;

    // Check obstacles (if OKO has reported any clusters)
    if (currentState.obstacles && currentState.obstacles.clusters) {
        // Simplified check - in real implementation would check actual cluster positions
        const obstacleCount = currentState.obstacles.obstacle_count || 0;
        if (obstacleCount > 10) {
            validation.checks.obstacles.pass = false;
            validation.checks.obstacles.message = 'âš ï¸ High obstacle density detected';
            validation.checks.obstacles.warnings.push(`${obstacleCount} obstacles currently detected`);
        }
    }

    // Check smoke zones (if pollutant sources detected)
    // This would check waypoint proximity to known smoke sources
    // Simplified for now

    currentValidation = validation;
    return validation;
}

// Display validation results
function displayValidationResults(validation) {
    const panel = document.getElementById('waypoint-validation-panel');
    const resultsEl = document.getElementById('validation-results');

    if (!validation) {
        panel.style.display = 'none';
        return;
    }

    panel.style.display = 'block';

    let html = '<div class="validation-checks">';

    // Display all checks
    for (const [key, check] of Object.entries(validation.checks)) {
        html += `<div class="validation-check ${check.pass ? 'pass' : 'warning'}">
            ${check.message}
        </div>`;

        if (check.warnings && check.warnings.length > 0) {
            check.warnings.forEach(warning => {
                html += `<div class="validation-warning">âš ï¸ ${warning}</div>`;
            });
        }
    }

    // Display estimates
    const minutes = Math.floor(validation.estimates.duration / 60);
    const seconds = Math.floor(validation.estimates.duration % 60);
    html += `
        <div class="validation-estimates">
            <div class="validation-estimate">
                â„¹ï¸ Total distance: <strong>${validation.estimates.distance.toFixed(0)}m</strong>
            </div>
            <div class="validation-estimate">
                â„¹ï¸ Estimated completion: <strong>${minutes}m ${seconds}s</strong>
            </div>
        </div>
    `;

    html += '</div>';
    resultsEl.innerHTML = html;

    // Log validation
    addHistoryEvent('info', `Waypoints validated: ${validation.waypoints.length} waypoints, ${validation.estimates.distance.toFixed(0)}m`);
}

// Mission Progress Bar System
const progressState = {
    startTime: null,
    distanceTraveled: 0,
    speedSamples: [],
    lastPosition: null
};

// Update mission progress
function updateMissionProgress() {
    const progressSection = document.getElementById('mission-progress-section');

    // Show progress bar when mission is running
    const runningStates = ['RUNNING', 'DRIVING', 'PAUSED'];
    if (runningStates.includes(missionState.state) && missionState.totalWaypoints > 0) {
        progressSection.style.display = 'block';

        // Calculate progress percentage
        const waypointProgress = (missionState.currentWaypoint / missionState.totalWaypoints) * 100;

        // Update progress bar
        const progressBar = document.getElementById('mission-progress-bar');
        const progressText = document.getElementById('mission-progress-text');
        progressBar.style.width = waypointProgress + '%';
        progressText.textContent = waypointProgress.toFixed(0) + '%';

        // Color-code based on speed
        if (currentState.gps.speed < 0.5) {
            progressBar.className = 'mission-progress-bar slow';
        } else if (currentState.gps.speed < 1.5) {
            progressBar.className = 'mission-progress-bar normal';
        } else {
            progressBar.className = 'mission-progress-bar fast';
        }

        // Update waypoint count
        document.getElementById('progress-waypoints').textContent =
            `${missionState.currentWaypoint}/${missionState.totalWaypoints}`;

        // Update distance (simplified - would need actual path tracking)
        if (currentValidation) {
            const totalDist = currentValidation.estimates.distance;
            const traveledDist = (missionState.currentWaypoint / missionState.totalWaypoints) * totalDist;
            document.getElementById('progress-distance').textContent =
                `${traveledDist.toFixed(0)}m / ${totalDist.toFixed(0)}m`;
        }

        // Update current speed from GPS
        const currentSpeed = currentState.gps.speed || 0;
        document.getElementById('progress-current-speed').textContent =
            currentSpeed.toFixed(1) + ' m/s';

        // Calculate average speed
        progressState.speedSamples.push(currentSpeed);
        if (progressState.speedSamples.length > 30) {
            progressState.speedSamples.shift(); // Keep last 30 samples
        }
        const avgSpeed = progressState.speedSamples.reduce((a, b) => a + b, 0) / progressState.speedSamples.length;
        document.getElementById('progress-avg-speed').textContent =
            avgSpeed.toFixed(1) + ' m/s';

        // Calculate time remaining
        if (currentValidation && avgSpeed > 0.1) {
            const totalDist = currentValidation.estimates.distance;
            const traveledDist = (missionState.currentWaypoint / missionState.totalWaypoints) * totalDist;
            const remainingDist = totalDist - traveledDist;
            const remainingTime = remainingDist / avgSpeed;
            const mins = Math.floor(remainingTime / 60);
            const secs = Math.floor(remainingTime % 60);
            document.getElementById('progress-time-remaining').textContent =
                `${mins}:${secs.toString().padStart(2, '0')}`;
        } else {
            document.getElementById('progress-time-remaining').textContent = '--:--';
        }

        // Update status
        let statusText = missionState.state;
        if (missionState.blockedReason && missionState.blockedReason !== 'None') {
            statusText += ` (${missionState.blockedReason})`;
        }
        document.getElementById('progress-status').textContent = statusText;

    } else {
        progressSection.style.display = 'none';
        progressState.speedSamples = [];
    }
}

// Hook into existing update functions to add history logging
const originalUpdateMissionStatus = updateMissionStatus;
updateMissionStatus = function(data) {
    const prevState = currentState.mission.state;
    const prevWaypoint = currentState.mission.waypoint;

    originalUpdateMissionStatus(data);

    // Log state changes
    if (prevState !== data.state) {
        addHistoryEvent('state', `State: ${prevState} â†’ ${data.state}`);
    }

    // Log waypoint progress
    if (prevWaypoint !== data.waypoint && data.waypoint > 0) {
        addHistoryEvent('waypoint', `Waypoint ${data.waypoint}/${data.total_waypoints} reached`);
    }

    // Log detours
    if (data.detour_active && !currentState.mission.detour_active) {
        addHistoryEvent('detour', 'Detour activated (obstacle avoidance)');
    }

    // Update progress bar
    updateMissionProgress();
};

// Hook into GPS updates for speed tracking
const originalUpdateGPS = updateGPS;
updateGPS = function(message) {
    originalUpdateGPS(message);

    // Calculate speed from position changes if not provided
    if (!currentState.gps.speed && progressState.lastPosition) {
        const dx = currentState.gps.x - progressState.lastPosition.x;
        const dy = currentState.gps.y - progressState.lastPosition.y;
        const dt = (Date.now() - progressState.lastPosition.time) / 1000; // seconds
        if (dt > 0) {
            const dist = Math.sqrt(dx * dx + dy * dy);
            currentState.gps.speed = dist / dt;
        }
    }

    progressState.lastPosition = {
        x: currentState.gps.x,
        y: currentState.gps.y,
        time: Date.now()
    };

    // Update progress display
    if (missionState.state === 'RUNNING' || missionState.state === 'DRIVING') {
        updateMissionProgress();
    }
};

// Hook into waypoint generation to trigger validation
const originalGenerateWaypoints = generateWaypoints;
generateWaypoints = function() {
    originalGenerateWaypoints();

    // Validate waypoints after they're received (with delay for ROS processing)
    setTimeout(async () => {
        if (missionState.waypoints && missionState.waypoints.length > 0) {
            addHistoryEvent('info', `Generated ${missionState.waypoints.length} waypoints`);
            const validation = await validateWaypoints(missionState.waypoints);
            displayValidationResults(validation);
        }
    }, 1500);
};

// Initialize Phase 2 features on page load
window.addEventListener('load', () => {
    setTimeout(() => {
        initMissionHistory();
        console.log('Phase 2 features initialized');
    }, 1500);
});
